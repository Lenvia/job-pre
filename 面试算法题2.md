[TOC]

æ³¨ï¼šâš ï¸è¡¨ç¤ºæœ‰æ›´å¥½çš„æ–¹æ³•æ²¡æœ‰è¡¥å……ã€‚ âš¡ï¸è¡¨ç¤ºéœ€è¦åŠ å¼ºè®°å¿†

<font color=fuchisa>ç²‰è‰²</font>ï¼šèµ·ç æˆ‘ä¸€å¼€å§‹æƒ³ä¸åˆ°/åšä¸å‡ºæ¥

<font color=red>çº¢è‰²</font>ï¼šè¾ƒéš¾

<font color=orange>æ©™è‰²</font>ï¼šç¨å¾®éš¾

<font color=purple>ç´«è‰²</font>ï¼šæŠ€å·§





## äºŒå‰æ ‘

### NC45 å®ç°äºŒå‰æ ‘å…ˆåºï¼Œä¸­åºå’Œååºéå†

https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&&tqId=37819&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */
#include <vector>
class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» the root of binary tree
     * @return intæ•´å‹vector<vector<>>
     */
    vector<vector<int>>res;
    vector<int>temp;
    
    void preOrder(TreeNode* root){
        if(root==nullptr)
            return;
        temp.push_back(root->val);
        preOrder(root->left);
        preOrder(root->right);
        return ;
    }
    void inOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        inOrder(root->left);
        temp.push_back(root->val);
        inOrder(root->right);
        return ;
    }
    void postOrder(TreeNode* root){
        if(root==nullptr)
            return;
        
        postOrder(root->left);
        postOrder(root->right);
        temp.push_back(root->val);
        return ;
    }
    
    
    vector<vector<int> > threeOrders(TreeNode* root) {
        res.clear();
        temp.clear();
        preOrder(root);
        res.push_back(temp);
        
        temp.clear();
        inOrder(root);
        res.push_back(temp);
        
        temp.clear();
        postOrder(root);
        res.push_back(temp);

        return res;
    }
};
```



### <font color=dodgerblue>NC13 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦</font>

BFSã€‚

æ³¨æ„è‡ªå®šä¹‰çš„ç»“æ„ä½“ï¼Œå…³äºèŠ‚ç‚¹å­˜çš„æ˜¯æŒ‡é’ˆã€‚

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @return intæ•´å‹
     */
    struct node{
        int level;
        TreeNode* ptr;
        node(){}
        node(int l, TreeNode* ptr): level(l), ptr(ptr){}
    };
    
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        int maxD = 0;
        queue<node>q;
        q.push(node(1, root));
        
        node temp;
        while(!q.empty()){
            temp = q.front();
            q.pop();
            
            if(temp.ptr->left)
                q.push(node(temp.level+1, temp.ptr->left));
            if(temp.ptr->right)
                q.push(node(temp.level+1, temp.ptr->right));
        }
        return temp.level;  // åªè¦å–æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„levelå°±è¡Œ
        
    }
};
```



ä¼˜åŒ–ï¼š

```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> q;
        if(!root) return 0;
        q.push(root);

        int depth = 0;
        int levelSize = 0;
        while(!q.empty()){
            depth++;
            levelSize = q.size();
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return depth;
    }
};
```



### NC15 æ±‚äºŒå‰æ ‘çš„å±‚åºéå†

BFSé˜Ÿåˆ—

ç»“æ„ä½“ å­˜å‚¨èŠ‚ç‚¹æŒ‡é’ˆä»¥åŠå±‚æ•°ã€‚

æ¯æ¬¡è¶…è¿‡å½“å‰æœ€å¤§å±‚ï¼Œpushè¯¥å±‚ç»“æœï¼Œç„¶åæ¸…ç©ºã€‚

æ³¨æ„ï¼é˜Ÿåˆ—ä¸ºç©ºæ—¶é€€å‡ºäº†whileï¼Œä½†è¿˜æœ‰ä¸€å±‚ç»“æœè®°å¾—push

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @return intæ•´å‹vector<vector<>>
     */
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int>>res;
        if(root==nullptr){
            return res;
        }
        vector<int>temp;  // ç”¨æ¥å­˜å‚¨ä¸€å±‚
        queue<node>q;
        q.push(node(root, 0));
        int maxLevel = 0;  // å½“å‰æœ€å¤§å±‚
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
//             printf("%d %d\n", val, level);
            
            if(level>maxLevel){  // ä¿å­˜ä¸Šä¸€å±‚ç»“æœï¼Œæ¸…ç©º
                maxLevel = level;
                res.push_back(temp);
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        res.push_back(temp);  // ç”±äºæœ€åé˜Ÿåˆ—ç©ºäº†ï¼Œæœ€åä¸€ä¸ªtempæ²¡å­˜
        return res;
    
    }
};
```



ã€æ¨èã€‘ä¼˜åŒ–ï¼

https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solutions/1398801/cong-shang-dao-xia-da-yin-er-cha-shu-ii-fzejw/

æ™®é€šå¹¿åº¦ä¼˜å…ˆæœç´¢æ¯æ¬¡åªå–ä¸€ä¸ªå…ƒç´ æ‹“å±•ï¼Œè€Œä¸‹é¢è¿‡ç¨‹ä¸­çš„ç¬¬ i æ¬¡è¿­ä»£å°±å¾—åˆ°äº†äºŒå‰æ ‘çš„ç¬¬ i å±‚çš„æ‰€æœ‰å…ƒç´ ã€‚

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;

        queue<TreeNode*>q;
        q.push(root);
        while(!q.empty()){
            int levelSize = q.size();
            res.push_back(vector<int>{});
            // æŠŠå½“å‰å±‚çš„æ”¾å…¥ç»“æœï¼Œå¹¶æŠŠä¸‹ä¸€å±‚çš„ä¸€æ¬¡æ€§pushè¿›å»
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                res.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```





### NC14 æŒ‰ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘

<font color=red>**æ¨èè§£æ³•äºŒ**</font>

NC 15 çš„è¿›é˜¶ã€‚

æ³¨æ„åœ¨å¾ªç¯ä¸­æ¯æ¬¡ level > maxLevel æ—¶ï¼Œtempå°±å˜æˆäº†ä¸Šä¸€å±‚çš„ç»“æœã€‚

è·³å‡ºå¾ªç¯åï¼Œtempè¡¨ç¤ºæœ€åä¸€å±‚çš„ç»“æœï¼Œå³levelå±‚ã€‚

```
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
    
};
*/
class Solution {
public:
    struct node{
        TreeNode* ptr;
        int level;
        node(TreeNode* p, int l): ptr(p), level(l){}
    };
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int>>res;
        if(pRoot==nullptr)
            return res;
        
        vector<int>temp;  // ç”¨æ¥å­˜å‚¨ä¸€å±‚
        queue<node>q;
        q.push(node(pRoot, 0));
        int maxLevel = 0;  // å½“å‰æœ€å¤§å±‚
        int val;
        int level;
        while(!q.empty()){
            node point = q.front();
            q.pop();
            
            val = point.ptr->val;
            level = point.level;
            
            if(level>maxLevel){  // ä¿å­˜ä¸Šä¸€å±‚ç»“æœï¼Œæ¸…ç©º
                maxLevel = level;
                if(level & 1)  // temp æ˜¯ä¸Šä¸€å±‚ç»“æœï¼æ‰€ä»¥å¦‚æœå½“å‰levelæ˜¯å¥‡ï¼Œåˆ™ä¸Šä¸€å±‚ä¸ç”¨ç¿»è½¬
                    res.push_back(temp);
                else{
                    reverse(temp.begin(), temp.end());
                    res.push_back(temp);
                }
                temp.clear();
            }
            temp.push_back(val);
            
            if(point.ptr->left!=nullptr){
                q.push(node(point.ptr->left, level+1));
            }
            if(point.ptr->right!=nullptr){
                q.push(node(point.ptr->right, level+1));
            }
        }
        // æœ€åä¸€å±‚è¿˜æ²¡æœ‰è¾“å‡º
        if((level+1) & 1)  // è¿™é‡Œtempå°±æ˜¯å½“å‰å±‚ç»“æœäº†ã€‚
            res.push_back(temp);
        else{
            reverse(temp.begin(), temp.end());
            res.push_back(temp);
        }
        return res;
    }
    
};
```



è§£æ³•äºŒï¼š

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;

        queue<TreeNode*>q;
        q.push(root);
        bool odd = true;
        while(!q.empty()){
            int levelSize = q.size();
            res.push_back(vector<int>{});
            // æŠŠå½“å‰å±‚çš„æ”¾å…¥ç»“æœï¼Œå¹¶æŠŠä¸‹ä¸€å±‚çš„ä¸€æ¬¡æ€§pushè¿›å»
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                res.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            if(!odd)
                reverse(res.back().begin(), res.back().end());
            odd = !odd;
        }
        return res;
    }
};
```



### å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ

```
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root == NULL) return root;

        mirrorTree(root->left);
        mirrorTree(root->right);
        TreeNode *node  = root->left;
        root->left = root->right;
        root->right = node;
        return root;
    }
};
```



### <font color=purple>å‰‘æŒ‡ Offer 28. å¯¹ç§°çš„äºŒå‰æ ‘</font>

å¦‚æœä¸€ä¸ªæ ‘çš„å·¦å­æ ‘ä¸å³å­æ ‘é•œåƒå¯¹ç§°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ ‘æ˜¯å¯¹ç§°çš„ã€‚

å› æ­¤ï¼Œè¯¥é—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºï¼šä¸¤ä¸ªæ ‘åœ¨ä»€ä¹ˆæƒ…å†µä¸‹äº’ä¸ºé•œåƒï¼Ÿ

å¦‚æœåŒæ—¶æ»¡è¶³ä¸‹é¢çš„æ¡ä»¶ï¼Œä¸¤ä¸ªæ ‘äº’ä¸ºé•œåƒï¼š

- å®ƒä»¬çš„ä¸¤ä¸ªæ ¹ç»“ç‚¹å…·æœ‰ç›¸åŒçš„å€¼
- **æ¯ä¸ªæ ‘çš„å³å­æ ‘éƒ½ä¸å¦ä¸€ä¸ªæ ‘çš„å·¦å­æ ‘é•œåƒå¯¹ç§°ã€‚**

æˆ‘ä»¬å¯ä»¥å®ç°è¿™æ ·ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡ã€ŒåŒæ­¥ç§»åŠ¨ã€ä¸¤ä¸ªæŒ‡é’ˆçš„æ–¹æ³•æ¥éå†è¿™æ£µæ ‘ï¼Œp æŒ‡é’ˆå’Œ q æŒ‡é’ˆä¸€å¼€å§‹éƒ½æŒ‡å‘è¿™æ£µæ ‘çš„æ ¹ï¼Œéšå p å³ç§»æ—¶ï¼Œq å·¦ç§»ï¼Œp å·¦ç§»æ—¶ï¼Œq å³ç§»ã€‚æ¯æ¬¡æ£€æŸ¥å½“å‰ p å’Œ q èŠ‚ç‚¹çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœç›¸ç­‰å†åˆ¤æ–­å·¦å³å­æ ‘æ˜¯å¦å¯¹ç§°ã€‚



```
class Solution {
public:

    bool check(TreeNode* a, TreeNode* b){
        if(!a && !b) return true;
        if(!a || !b) return false;

        return (a->val == b->val) && check(a->left, b->right) && check(a->right, b->left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```





### âš¡ï¸<font color=orange>NC6 äºŒå‰æ ‘æœ€å¤§è·¯å¾„å’Œ</font>

https://www.nowcoder.com/practice/da785ea0f64b442488c125b441a4ba4a?tpId=196&tqId=37050&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1&difficulty=undefined&judgeStatus=undefined&tags=&title=

https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

maxGain è¿”å›çš„æ˜¯ å•å­æ ‘çš„æœ€å¤§å’Œï¼Œæœ€å¤§è·¯å¾„å’Œæ˜¯è¿™ä¸ªè¿‡ç¨‹ä¸­ç”¨å…¨å±€å˜é‡æ›´æ–°çš„ï¼

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @return intæ•´å‹
     */
    int MAX_SUM = -1001;  // å³ä½¿å…¨æ˜¯è´Ÿæ•°ï¼Œæœ€å°ä¹Ÿä¸ä¼šå°äº-1001
    
    int maxGain(TreeNode* node){
        if(node==nullptr){
            return 0;
        }
        // å·¦å³å­æ ‘èƒ½ç»™è¯¥èŠ‚ç‚¹çš„è´¡çŒ®å€¼
        // ä¸0æ¯”è¾ƒæ˜¯å› ä¸ºï¼Œå¦‚æœå­æ ‘åè€Œæä¾›è´Ÿè´¡çŒ®ï¼Œå°±ç›´æ¥æŠ›å¼ƒ
        int left_gain = max(maxGain(node->left), 0);
        int right_gain = max(maxGain(node->right), 0);
        
        int cur_sum = node->val + left_gain + right_gain;  // å½“å‰è·¯å¾„å’Œ
        MAX_SUM = max(MAX_SUM, cur_sum);
        return node->val + max(left_gain, right_gain);  // æ¯æ¬¡åªèƒ½é€‰æ‹©ä¸€é¢—å­æ ‘
    }
    int maxPathSum(TreeNode* root) {
        maxGain(root);
        return MAX_SUM;
    }
};
```



### âš¡ï¸<font color=red>NC102 åœ¨äºŒå‰æ ‘ä¸­æ‰¾åˆ°ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ</font>

> âš ï¸å¦‚æœæœ‰ä¸€ä¸ªèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œç”šè‡³ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œæ€ä¹ˆå¤„ç†ï¼Ÿ
>
> ä¸ªäººæ€è·¯ï¼šif(node->val == o1 || node->val == o2) æ—¶ï¼Œåšä¸ªæ ‡è®°ï¼Œä¾‹å¦‚count++ï¼Œæˆ–è€…ç›´æ¥è®°å½•å½“å‰valã€‚æœ€ååˆ¤æ–­ count æ˜¯å¦ä¸º2



æ–¹æ³•ä¸€ï¼šé€’å½’

è®¾é—®é¢˜ä¸º`LCA(root, o1, o2)`, è¯¥é—®é¢˜æœ‰ä»¥ä¸‹é€’å½’æ€§è´¨ï¼š

- å¦‚æœo1å’Œo2éƒ½åœ¨rootçš„å·¦å­æ ‘ä¸­ï¼Œé‚£ä¹ˆ`LCA(root, o1, o2) = LCA(root->left, o1, o2)`.
- å¦‚æœo1å’Œo2éƒ½åœ¨rootçš„å³å­æ ‘ä¸­ï¼Œé‚£ä¹ˆ`LCA(root, o1, o2) = LCA(root->right, o1, o2)`.
- å¦‚æœä¸€ä¸ªåœ¨å·¦å­æ ‘ï¼Œä¸€ä¸ªåœ¨å³å­æ ‘ï¼Œæ˜¾ç„¶rootå°±æ˜¯ç­”æ¡ˆ



```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @param o1 intæ•´å‹ 
     * @param o2 intæ•´å‹ 
     * @return intæ•´å‹
     */
    TreeNode* LCA(TreeNode* node, int o1, int o2){
        if(node==nullptr)
            return nullptr;
        // å¦‚æœè‡³å°‘åŒ…å«ä¸€ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›è‡ªå·±
        if(node->val == o1 || node->val == o2)
            return node;
        // æŸ¥æ‰¾å·¦å³å­æ ‘ã€‚æ³¨æ„lnode, rnodeä¸ä»£è¡¨å·¦å³èŠ‚ç‚¹ã€‚è€Œæ˜¯å·¦å³å­æ ‘é‡Œçš„å…¬å…±ç¥–å…ˆï¼ˆæœ€è¿‘çš„ï¼‰
        TreeNode *lnode, *rnode;
        lnode = LCA(node->left, o1, o2);
        rnode = LCA(node->right, o1, o2);
        
        if(lnode==nullptr)  // å¦‚æœå·¦å­æ ‘é‡Œæ²¡æ‰¾åˆ°ï¼Œé‚£ä¸¤ä¸ªèŠ‚ç‚¹è‚¯å®šéƒ½åœ¨å³å­æ ‘é‡Œ
            return rnode;
        if(rnode==nullptr)
            return lnode;
        // å¦‚æœå·¦å­æ ‘å³å­æ ‘éƒ½åŒ…å«ç›®æ ‡èŠ‚ç‚¹ï¼Œé‚£å…¬å…±ç¥–å…ˆå°±æ˜¯è‡ªå·±
        return node;
        
    }
    
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        TreeNode* node = LCA(root, o1, o2);
        return node->val;
    }
};
```



æ–¹æ³•äºŒï¼šdfs

æŠŠä»æ ¹èŠ‚ç‚¹åˆ°o1, o2çš„è·¯å¾„æ‰“å°å‡ºæ¥ã€‚

é€ä¸ªæ¯”è¾ƒï¼Œå¦‚æœå‡ºç°ä¸ä¸€æ ·çš„ï¼Œå°±æ˜¯è¿™ä¸ªä¸ä¸€æ ·çš„çˆ¶èŠ‚ç‚¹

å¦‚æœéƒ½ä¸€æ ·ï¼Œè¿”å›çŸ­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @param o1 intæ•´å‹ 
     * @param o2 intæ•´å‹ 
     * @return intæ•´å‹
     */
    vector<int>vec1;
    vector<int>vec2;
    
    bool dfs(TreeNode* node, vector<int>& vec, int target){
        if(node->val == target)
            return true;
        
        if(node->left!=nullptr){
            vec.push_back(node->left->val);
            if(dfs(node->left, vec, target))
                return true;
            vec.pop_back();
        }
        if(node->right!=nullptr){
            vec.push_back(node->right->val);
            if(dfs(node->right, vec, target))
                return true;
            vec.pop_back();
        }
        return false;
    }
    
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        vec1.clear();
        vec2.clear();
        vec1.push_back(root->val);
        vec2.push_back(root->val);
        dfs(root, vec1, o1);
        dfs(root, vec2, o2);
        
        int len = min(vec1.size(), vec2.size());
        for(int i=0; i<len; i++){
            if(vec1[i]==vec2[i])
                continue;
            else return vec1[i-1];  // å¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™æ˜¯çˆ¶èŠ‚ç‚¹
        }
        // èƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜çŸ­çš„vecåŒ…å«åœ¨é•¿çš„é‡Œ
        return vec1[len-1];
    }
};
```



### NC12 é‡å»ºäºŒå‰æ ‘

å¹³å¹³æ— å¥‡é‡å»ºäºŒå‰æ ‘

```
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    
    TreeNode* createTree(vector<int>& pre, vector<int>& vin, int prel, int prer, int vinl, int vinr){
        if(prel>prer)
            return nullptr;
        if(prel==prer)  // åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
            return new TreeNode(pre[prel]);
        
        TreeNode* root = new TreeNode(pre[prel]);
        // åœ¨vinçš„ [vinl, vinr]ä¸­æ‰¾åˆ°rootæ‰€åœ¨çš„ä½ç½®
        int index;
        for(int i=vinl; i<=vinr; i++){
            if(vin[i]==root->val){
                index = i;
                break;
            }
        }
        int left_num = index-vinl;
        int right_num = vinr-index;
        
        root->left = createTree(pre, vin, prel+1, prel+left_num, vinl, index-1);
        root->right = createTree(pre, vin, prer-right_num+1, prer, index+1, vinr);
        
        return root;
    }
    
    
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        return createTree(pre, vin, 0, pre.size()-1, 0, vin.size()-1);
    }
};
```



### NC136 è¾“å‡ºäºŒå‰æ ‘çš„å³è§†å›¾

æ ¹æ®å‰åº+ä¸­åºé‡å»ºäºŒå‰æ ‘ï¼Œå±‚åºéå†ã€‚

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     * æ±‚äºŒå‰æ ‘çš„å³è§†å›¾
     * @param preOrder intæ•´å‹vector å…ˆåºéå†
     * @param inOrder intæ•´å‹vector ä¸­åºéå†
     * @return intæ•´å‹vector
     */

    TreeNode* create(vector<int>& preOrder, vector<int>& inOrder, int preL, int preR, int inL, int inR){
        if(preL > preR) return nullptr;
        if(preL == preR) return new TreeNode(preOrder[preL]);

        int index;
        auto root = new TreeNode(preOrder[preL]);
        for(int i=inL; i<=inR; i++){
            if(inOrder[i] == root->val){
                index = i;
                break;
            }
        }
        int leftNum = index - inL;
        int rightNum = inR - index;

        root->left = create(preOrder, inOrder, preL+1, preL+leftNum, inL, index-1);
        root->right = create(preOrder, inOrder, preR-rightNum+1, preR, index+1, inR);

        return root;
    }     
    vector<int> solve(vector<int>& preOrder, vector<int>& inOrder) {
        int len = preOrder.size();
        auto root = create(preOrder, inOrder, 0, len-1, 0, len-1);

        vector<int>res;

        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int levelSize = q.size();
            for(int i=0; i<levelSize; i++){
                auto node = q.front(); q.pop();
                if(i==levelSize-1){  // è¯¥å±‚æœ€åä¸€ä¸ª
                    res.push_back(node->val);
                }
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```







### âš¡ï¸<font color=purple>NC62 åˆ¤æ–­æ˜¯ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘</font>

é€’å½’ï¼ï¼æ³¨æ„çœ‹é¢˜ã€‚

å¹³è¡¡äºŒå‰æ ‘ï¼ˆBalanced Binary Treeï¼‰ï¼Œå…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼šå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œ**å¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€æ£µå¹³è¡¡äºŒå‰æ ‘**ã€‚

```
class Solution {
public:
    
    int dfs(TreeNode* node, int curL){
        if(node==nullptr)
            return curL;
        
        int ll = dfs(node->left, curL+1);
        int rl = dfs(node->right, curL+1);
        
        return max(ll, rl);
    }
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(pRoot==nullptr)
            return true;
        int leftL = dfs(pRoot->left, 0);
        int rightL = dfs(pRoot->right, 0);
        
//         printf("%d %d", leftL, rightL);
        
        if(abs(leftL - rightL)<=1 && IsBalanced_Solution(pRoot->left) && IsBalanced_Solution(pRoot->right))
            return true;
        else return false;
    }
};
```

å®˜æ–¹é¢˜è§£ï¼š

```
class Solution {
public:
    int height(TreeNode* root) {
        if (root == NULL) {
            return 0;
        } else {
            return max(height(root->left), height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) {
            return true;
        } else {
            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
};

```





### âš¡ï¸[lc]<font color=orange>äºŒå‰æ ‘æ±‚å’Œè·¯å¾„</font>

ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½å«æœ‰ä¸€ä¸ªæ•´æ•°æ•°å€¼(è¯¥å€¼æˆ–æ­£æˆ–è´Ÿ)ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ‰“å°èŠ‚ç‚¹æ•°å€¼æ€»å’Œç­‰äºæŸä¸ªç»™å®šå€¼çš„æ‰€æœ‰è·¯å¾„çš„æ•°é‡ã€‚æ³¨æ„ï¼Œ**è·¯å¾„ä¸ä¸€å®šéå¾—ä»äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹æˆ–å¶èŠ‚ç‚¹å¼€å§‹æˆ–ç»“æŸ**ï¼Œä½†æ˜¯å…¶æ–¹å‘å¿…é¡»å‘ä¸‹(åªèƒ½ä»çˆ¶èŠ‚ç‚¹æŒ‡å‘å­èŠ‚ç‚¹æ–¹å‘)ã€‚

https://leetcode-cn.com/problems/paths-with-sum-lcci/

æ€è·¯å°±æ˜¯æŠŠæ‰€æœ‰èŠ‚ç‚¹éƒ½å½“ä½œæ ¹èŠ‚ç‚¹ï¼Œå³æ¯ä¸ªèŠ‚ç‚¹éƒ½ä½¿ç”¨ä¸€æ¬¡dfså‡½æ•°

dfså‡½æ•°è¿™é‡Œä¸ç”¨é¢å¤–ä¸€ä¸ªå‚æ•°ç»´æŠ¤ä»èµ·å§‹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„èŠ‚ç‚¹å€¼æ€»å’Œï¼Œè€Œæ˜¯**ç›´æ¥ä¿®æ”¹sum**,ä¹Ÿå¯ä»¥è¾¾åˆ°ç›¸åŒçš„æ•ˆæœ,

å¦‚æœsum==0ï¼Œåˆ™æ˜¯ä¸€ä¸ªæœ‰æ•ˆç­”æ¡ˆ,ans++

è€Œåœ¨ä¸»å‡½æ•°ä¸­é€’å½’è°ƒç”¨è‡ªå·±,ä¿è¯æ‰€æœ‰èŠ‚ç‚¹éƒ½èƒ½ä½¿ç”¨åˆ°dfså‡½æ•°

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans;
    void dfs(TreeNode *root,int sum){
        if(root==NULL)
            return ;
        sum-=root->val;
        if(sum==0)
            ans++; // ä¸èƒ½ç›´æ¥returnï¼Œå› ä¸ºå¯èƒ½æœ‰èŠ‚ç‚¹ä¸º0
            
        dfs(root->left,sum);
        dfs(root->right,sum);
        return;
    }
    int pathSum(TreeNode* root, int sum) {
        if(root==NULL)
            return 0;
        dfs(root,sum);
        pathSum(root->left,sum);
        pathSum(root->right,sum);
        return ans;
    }
};
```





### NC5 äºŒå‰æ ‘æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„å’Œ

ç®€å•dfsã€‚

ä½†æ˜¯æ³¨æ„ï¼Œç»Ÿè®¡çš„æ—¶åˆ»åº”è¯¥æ˜¯åˆ°è¾¾å¶å­ç»“ç‚¹ï¼ˆleft == nullptr && right == nullptrï¼‰ï¼Œè€Œä¸æ˜¯å½“å‰èŠ‚ç‚¹ä¸ºç©ºæ—¶ã€‚

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @return intæ•´å‹
     */
    int sum = 0;
    
    void dfs(TreeNode* node, string cur){
        string temp = cur;  // ä¸å¯èƒ½æœ‰ç©ºèŠ‚ç‚¹è¿›å…¥dfs
        temp.push_back(node->val+'0');
        
        // æ³¨æ„ï¼Œåªæœ‰å·¦å³å­æ ‘éƒ½ä¸ºç©ºçš„æ—¶å€™æ‰ç®—å¶å­ç»“ç‚¹
        if(node->left == nullptr && node->right == nullptr){
            sum += stoi(temp);
            return ;
        }

        if(node->left){
            dfs(node->left, temp);
        }
        if(node->right){
            dfs(node->right, temp);
        }

    }
    
    int sumNumbers(TreeNode* root) {
        if(root==nullptr)
            return 0;
        else{
            dfs(root, "");
            return sum;
        }
    }
};
```



### NC8 äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„(äºŒ)

å¹³å¹³æ— å¥‡DFS

```
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
  public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     *
     * @param root TreeNodeç±»
     * @param target intæ•´å‹
     * @return intæ•´å‹vector<vector<>>
     */
    vector<vector<int>> res;
    vector<int>temp;

    void dfs(TreeNode* node, int target) {
        target -= node->val;
        if (target == 0) {
            if (!node->left && !node->right) { // åªæœ‰å¶å­ç»“ç‚¹æ‰èƒ½retrun
                res.push_back(temp);
                return ;
            }
        }

        if (node->left) {
            temp.push_back(node->left->val);
            dfs(node->left, target);
            temp.pop_back();
        }
        if (node->right) {
            temp.push_back(node->right->val);
            dfs(node->right, target);
            temp.pop_back();
        }
    }

    vector<vector<int> > FindPath(TreeNode* root, int target) {
        if (root == nullptr)
            return res;
        temp.push_back(root->val);
        dfs(root, target);

        return res;
    }
};
```



### NC9 äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„(ä¸€)

NC8 ä½ éƒ½ä¼šï¼Œè¿™æ¯”å®ƒæ›´ç®€ç•¥ã€‚

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» 
     * @param sum intæ•´å‹ 
     * @return boolå¸ƒå°”å‹
     */
    bool dfs(TreeNode* node, int expectNumber){
        if(expectNumber == node->val){
            if(!node->left && !node->right){  // åªæœ‰å¶å­ç»“ç‚¹æ‰èƒ½retrun
                return true;
            }
        }
        
        expectNumber -= node->val;
        
        if(node->left){
            if(dfs(node->left, expectNumber))
                return true;
        }
        if(node->right){
            if(dfs(node->right, expectNumber))
                return true;;
        }
        return false;
    }
    
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==nullptr)
            return false;
        return dfs(root, sum);
    }
};
```



### NC98 åˆ¤æ–­t1æ ‘ä¸­æ˜¯å¦æœ‰ä¸t2æ ‘å®Œå…¨ç›¸åŒçš„å­æ ‘

é€’å½’ã€‚

ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªisContainsï¼Œä¸€ä¸ªisEqual

å› ä¸ºæ ‘ä¸­çš„å€¼æ˜¯ä¸¤ä¸¤ä¸åŒçš„ï¼Œæ‰€ä»¥åœ¨isContainsé‡Œï¼Œå¦‚æœroot1->valä¸ç­‰äºroot2->valï¼Œå°±ç»§ç»­é€’å½’root1çš„å·¦å³å­æ ‘ï¼Œåªè¦å·¦å³å­æ ‘æœ‰ä¸€ä¸ªcontainså°±è¡Œï¼Œæ‰€ä»¥æ˜¯return (isContains(root1->left, root2) || isContains(root1->right, root2));

åœ¨isContainsçš„é€’å½’é‡Œï¼Œå¦‚æœé‡åˆ°root1->val == root2->val ï¼ˆæ­¤root1å’Œä¸Šä¸€è¡Œçš„root1æ„ä¹‰ä¸ä¸€å®šä¸€æ ·ï¼‰ï¼Œåˆ™å¿…é¡»æ£€æŸ¥root1çš„æ‰€æœ‰ç»“æ„å’Œroot2æ˜¯å¦ç›¸åŒã€‚æ­¤æ—¶è¯¥è°ƒç”¨isEqualã€‚return isEqual(node1->left, node2->left) && isEqual(node1->right, node2->right);

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root1 TreeNodeç±» 
     * @param root2 TreeNodeç±» 
     * @return boolå¸ƒå°”å‹
     */
    
    bool isEqual(TreeNode* node1, TreeNode* node2){
        if(node1==nullptr && node2==nullptr) return true;
        if(node1==nullptr || node2==nullptr) return false;
        
        // åˆ°è¿™é‡Œè¯´æ˜node1å’Œnode2éƒ½æœ‰å€¼
        if(node1->val != node2->val)
            return false;
        return isEqual(node1->left, node2->left) && isEqual(node1->right, node2->right);
    }
    
    bool isContains(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr) return false;
        if(root1->val == root2->val){  // å¦‚æœç›¸ç­‰äº†ï¼Œå¿…é¡»å·¦å³å­æ ‘å…¨éƒ¨ç›¸ç­‰
            return (isEqual(root1->left, root2->left) && isEqual(root1->right, root2->right));
        }
        
        return (isContains(root1->left, root2) || isContains(root1->right, root2));
    }
};
```



### ğŸ”¥âš¡ï¸<font color=dodgerblue>NC60 åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯å¦ä¸ºæœç´¢äºŒå‰æ ‘å’Œå®Œå…¨äºŒå‰æ ‘</font>

åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯å¦ä¸ºã€ŒäºŒå‰æœç´¢æ ‘ã€çš„é€šç”¨æ–¹æ³•ä¸ºï¼šå¯¹è¯¥äºŒå‰æ ‘è¿›è¡Œä¸­åºéå†ï¼Œè‹¥éå†ç»“æœä¸ºã€Œä¸¥æ ¼ã€å•è°ƒé€’å¢çš„ï¼Œåˆ™æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå¦åˆ™ä¸æ˜¯ã€‚

åˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦ä¸ºã€Œå®Œå…¨äºŒå‰æ ‘ã€çš„æ–¹å¼ä¸ºï¼šå¯¹å…¶è¿›è¡Œå±‚æ¬¡éå†ï¼Œè‹¥é‡åˆ°ä¸€ä¸ªç©ºç»“ç‚¹ï¼Œåˆ™å…¶åé¢çš„ç»“ç‚¹å¿…é¡»å…¨ä¸ºç©ºç»“ç‚¹ï¼Œå¦åˆ™ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚åœ¨è¿™é‡Œæ”¹å˜äº†ä¸€ä¸‹å®ç°ï¼Œ**å¦‚æœæœ‰ç¼ºå°‘å·¦å„¿å­æˆ–è€…å³å„¿å­ï¼Œä½†æ˜¯è¯¥èŠ‚ç‚¹æœ‰å„¿å­ï¼ˆä¸æ˜¯å¶å­ç»“ç‚¹ï¼‰ï¼Œè¿”å›falseã€‚ å¦‚æœäºŒå‰æ ‘èŠ‚ç‚¹æœ‰å³å„¿å­ä½†æ˜¯æ²¡æœ‰å·¦å„¿å­ï¼Œç›´æ¥è¿”å›falseï¼‰**

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNodeç±» the root
     * @return boolå¸ƒå°”å‹vector
     */
    vector<int>vec;
    void inOrder(TreeNode* node){
        if(node==nullptr)
            return ;
        inOrder(node->left);
        vec.push_back(node->val);
        inOrder(node->right);
    }
    
    vector<bool> judgeIt(TreeNode* root) {
        bool res1, res2;
        inOrder(root);
        res1 = true;
        if(vec.size()<=1) res1 = true;
        else{
            for(int i=0; i<vec.size()-1; i++){
//                 printf("%d ", vec[i]);
                if(vec[i]>=vec[i+1]){
                    res1 = false;
                    break;
                }
            }
        }
        
        res2 = true;
        
        queue<TreeNode*>q;
        if(root)
            q.push(root);
        TreeNode* temp;
        int flag = 0;
        // å®Œå…¨äºŒå‰æ ‘åœ¨é‡åˆ°ç©ºèŠ‚ç‚¹ä¹‹åå‰©ä½™çš„åº”å½“å…¨æ˜¯ç©ºèŠ‚ç‚¹
        while(!q.empty()){
            temp = q.front();
            q.pop();
            
            // å¦‚æœflagä¸º1ï¼Œä¸”å­˜åœ¨èŠ‚ç‚¹å·¦å³å­æ ‘ä¸ä¸ºç©ºï¼Œåˆ™false
            if(flag && (temp->left || temp->right)){
                res2 = false;
                break;
            }
            // å·¦å³å­æ ‘æœ‰ä¸€ä¸ªä¸ºç©º
            if(temp->left == nullptr || temp->right == nullptr){
                if(temp->right){  // åªæœ‰å·¦å­æ ‘ä¸ºç©ºï¼Œä¸€å®šä¸æ˜¯
                    res2 = false;
                    break;
                }
                else{
                    flag = 1;  // åªæœ‰å³å­æ ‘ä¸ºç©ºï¼Œæˆ–è€…ä¸¤ä¸ªå­æ ‘éƒ½ä¸ºç©º
                    if(temp->left) q.push(temp->left);
                    continue;
                }
            }
            
            // åˆ°è¿™é‡Œè¯´æ˜å·¦å³å­æ ‘éƒ½ä¸ä¸ºç©º
            q.push(temp->left);
            q.push(temp->right);
            
        }
        return vector<bool>{res1, res2};
    }
};
```



### âš¡ï¸<font color=red>å‰‘æŒ‡ Offer 36. äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨</font>

https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/

è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„å¾ªç¯åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„èŠ‚ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­èŠ‚ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚

<img src="https://pic.leetcode-cn.com/1599401091-PKIjds-Picture1.png" alt="Picture1.png" style="zoom:50%;" />



æ€è·¯ï¼šä¸­åºéå†åº”è¯¥èƒ½æ„è¯†åˆ°ï¼Œä½†æ˜¯ä¸­åºéå†æ€ä¹ˆåº”ç”¨å‘¢ï¼Ÿ

ä¸­åºéå†ï¼š

```
inOrder(cur->left)
visit(cur)
inOrder(cur->right)
```

å³ï¼Œéå†å®Œ cur->left èŠ‚ç‚¹åå°±è½®åˆ°äº† curã€‚é‚£æˆ‘ä»¬å¯ä»¥è€ƒè™‘åœ¨ inOrder(cur->left) è¿™ä¸€æ­¥ä¿å­˜ä¸€ä¸ªæœ€è¿‘æ¯” cur å°çš„èŠ‚ç‚¹ï¼ˆç”¨æŒ‡é’ˆè®°å½•ï¼Œä¾‹å¦‚ preï¼‰ã€‚

çœ‹æç«¯æƒ…å†µï¼Œæœ€å·¦ä¸‹è§’çš„èŠ‚ç‚¹ï¼ˆä¾‹å¦‚ä¸Šå›¾ä¸­çš„ node1ï¼‰ï¼Œå®ƒåœ¨éå†å®Œä¹‹åå°±è½®åˆ°äº†node 2ã€‚æ­¤æ—¶ pre å°±åº”è¯¥æŒ‡å‘node1ï¼ŒcuræŒ‡å‘node2ã€‚ï¼ˆå³ åœ¨ inOrder(node1) çš„ç»“æŸæ—¶åº”è¯¥ pre = node1ï¼Œå³pre = curã€‚

ç„¶ååˆ°äº† visit(node2) æ—¶ï¼Œ ç›´æ¥ pre(node1) å’Œ cur(node2) ç›¸äº’æŒ‡å‘å°±è¡Œã€‚ç„¶åå†æ›´æ–° pre = cur(node2)ï¼Œäºæ˜¯åœ¨ inOrder(node3)æ—¶ä¹Ÿä¼šæœ‰ ç›´æ¥ pre(node2) å’Œ cur(node3) ç›¸äº’æŒ‡å‘ï¼Œå¹¶æ›´æ–° pre = cur(node3)...  éå†å®Œåï¼Œç›¸å½“äº inOrder(node2)å·²ç»“æŸï¼Œcur = node4ï¼Œæ­¤æ—¶preæ­£å¥½æ˜¯ node3ï¼Œå³æœ€è¿‘çš„æ¯” node4å°çš„èŠ‚ç‚¹ã€‚

ç„¶åæ˜¯å¾ªç¯é—®é¢˜ï¼Œä»ä¸Šé¢çš„æ­¥éª¤å¯ä»¥çŸ¥é“ï¼Œåªæœ‰å½“ visit(node1)æ—¶ï¼Œpreæ˜¯ç©ºçš„ï¼Œå¹¶ä¸”æ­¤æ—¶æ­£å¥½æ˜¯æœ€å°èŠ‚ç‚¹ã€‚æ‰€ä»¥å¯ä»¥ç”¨å…¨å±€æŒ‡é’ˆ head æ¥æŒ‡å‘ cur(node1)ã€‚

æœ€æœ€åï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½ä¸­åºéå†å®Œã€‚headæŒ‡å‘æœ€å°èŠ‚ç‚¹ï¼Œpreæ˜¯æœ€å¤§èŠ‚ç‚¹ã€‚ä¸€è¿æ¥å°±è¡Œäº†ã€‚

```
class Solution {
public:
    Node* pre, *head;

    void inOrder(Node* cur){
        if(!cur) return ;

        inOrder(cur->left);
        // å¯¹äºæœ¬èŠ‚ç‚¹
        if(!pre){  // å½“ä¸”ä»…å½“åˆ°è¾¾å·¦ä¸‹è§’æœ€å°èŠ‚ç‚¹æ—¶ pre æ‰ä¸ºç©º
            head = cur;
            cur->left = pre;
        }
        else{  // å…¶ä»–æƒ…å†µï¼Œpreå°±æ˜¯æœ€è¿‘çš„ä¸€ä¸ªæ¯”curå°çš„èŠ‚ç‚¹
            cur->left = pre;
            pre->right = cur;
        }
        pre = cur;

        inOrder(cur->right);
    }

    Node* treeToDoublyList(Node* root) {
        if(!root) return NULL;
        pre = NULL;
        inOrder(root);
        head->left = pre;  // æœ€å°èŠ‚ç‚¹æŒ‡å‘æœ€å¤§èŠ‚ç‚¹çš„æŒ‡é’ˆ
        pre->right = head;

        return head;
    }
};
```



## åŠ¨æ€è§„åˆ’

### NC68 è·³å°é˜¶

ç®€å•æ–æ³¢é‚£å¥‘ã€‚

æ³¨æ„ç©ºé—´å¤æ‚åº¦ä¸º O(1)ï¼Œæ‰€ä»¥è¦å¼€å¸¸æ•°ç©ºé—´ã€‚

dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3]

```
class Solution {
public:
    int jumpFloor(int number) {
        int dp[3];
        
        dp[1] = 1;
        dp[2] = 2;
        if(number<3)
            return dp[number];
        
        for(int i=3; i<=number; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[number%3];
    }
};
```



### âš ï¸NC65 æ–æ³¢é‚£å¥‘æ•°åˆ—

O(n)è§£æ³•å’Œä¸Šä¸€é¢˜ä¸€æ ·ã€‚

```
class Solution {
public:
    int Fibonacci(int n) {
        if(n<=2) return 1;
        int dp[3];
        dp[1] = 1;
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            dp[i%3] = dp[(i-1)%3] + dp[(i-2)%3];
        }
        return dp[n%3];
    }
};
```

O(logn)è§£æ³•ï¼š

çŸ©é˜µå¿«é€Ÿå¹‚

https://www.cnblogs.com/simplc/p/6742928.html





### NC19 è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ

å¼€å¸¸æ•°ç©ºé—´ã€‚

dp[i%2] = max(dp[(i-1)%2], 0) + array[i]

```
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int n = array.size();
        if(n==1){
            return array[0];
        }
        
        int dp[2];
        dp[0] = array[0];
        
        int max_sum = dp[0];
        for(int i=1; i<n; i++){
            dp[i%2] = max(dp[(i-1)%2], 0) + array[i];
            max_sum = max(max_sum, dp[i%2]);
        }
        return max_sum;
    }
};
```





### <font color=dodgerblue>æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰</font>

https://leetcode-cn.com/problems/longest-common-subsequence/

```
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.length();
        int n = text2.length();
        int dp[m+1][n+1];
        memset(dp, 0, sizeof(dp));

        text1.insert(0, " ");
        text2.insert(0, " ");

        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(text1[i] == text2[j])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};
```



### NC92 æœ€é•¿å…¬å…±å­åºåˆ—(äºŒ)

æœ€é•¿å…¬å…±å­åºåˆ—+è¾“å‡ºæ­¤åºåˆ—ã€‚

å¤åŸæ—¶ä»åå¾€å‰ã€‚

```
class Solution {
public:
    /**
     * longest common subsequence
     * @param s1 stringå­—ç¬¦ä¸² the string
     * @param s2 stringå­—ç¬¦ä¸² the string
     * @return stringå­—ç¬¦ä¸²
     */
    string LCS(string s1, string s2) {
        string res;
        s1.insert(0, " ");
        s2.insert(0, " ");
        
        int dp[s1.length()+1][s2.length()+1];
        
        for(int j=0; j<s2.length(); j++)
            dp[0][j] = 0;
        for(int i=0; i<s1.length(); i++)
            dp[i][0] = 0;
        
        int maxx = -1;
        for(int i=1; i<s1.length(); i++){
            for(int j=1; j<s2.length(); j++){
                if(s1[i]==s2[j]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
                maxx = max(maxx, dp[i][j]);
            }
        }
        if(maxx<=0)
            return "-1";
        
        // å¤åŸ
        for(int i=s1.length()-1, j=s2.length()-1; i>=1 && j>=1; ){
            if(s1[i]==s2[j]){
                res.push_back(s1[i]);
                i--; j--;
            }
            else{
                if(dp[i][j]==dp[i-1][j]){
                    i--;
                }
                else j--;
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```



### <font color=orange>NC127 æœ€é•¿å…¬å…±å­ä¸²</font>

dp\[i][j] è¡¨ç¤º**ä»¥ str1\[i] å’Œ str2\[j] ç»“å°¾çš„**æœ€é•¿å…¬å…±å­ä¸²çš„é•¿åº¦

```

class Solution {
  public:
    /**
     * longest common substring
     * @param str1 stringå­—ç¬¦ä¸² the string
     * @param str2 stringå­—ç¬¦ä¸² the string
     * @return stringå­—ç¬¦ä¸²
     */
    string LCS(string str1, string str2) {
        str1.insert(0, " ");
        str2.insert(0, " ");

        int len1 = str1.length();
        int len2 = str2.length();
        int dp[len1][len2];
        memset(dp, 0, sizeof(dp));

        int maxx = 0;
        int start = 0;
        string res;
        for (int i = 1; i < len1; i++) {
            for (int j = 1; j < len2; j++) {
                if (str1[i] == str2[j]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if (maxx < dp[i][j]) {
                        maxx = dp[i][j];
                        start = i - dp[i][j] + 1;
                    }
                }
                // else dp[i][j] = 0;
            }
        }

        res = str1.substr(start, maxx);
        return res;
    }
};
```





### âš¡ï¸<font color=red>NC 91 æœ€é•¿ä¸Šå‡å­åºåˆ—(ä¸‰)</font>

HDU 5748 çš„åŠ å·¥ï¼https://vjudge.net/problem/HDU-5748

select å’Œ level çš„æ•°ç»„æ±‚è§£æ–¹å¼ä¸€æ ·ï¼Œä½†æ˜¯è¿™ä¸€é¢˜è¦æ±‚å­—å…¸åºæœ€å°ï¼Œæ‰€ä»¥åº”å½“ä»åå‘å‰æ”¾å…¥ç»“æœã€‚

levelä»¥åˆ°è‡ªå·±ä¸ºæ­¢æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ä½œä¸ºå…ƒç´ ã€‚level[i]è¡¨ç¤ºåˆ°è‡ªå·±ä¸ºæ­¢çš„æœ€é•¿ä¸Šå‡åºåˆ—çš„é•¿åº¦ã€‚

select å¹¶ä¸æ˜¯ç»“æœï¼

ä¾‹å¦‚ è¾“å…¥ [2,1,5,3,6,4,8,9,7]ï¼Œå¾—åˆ°select [1, 3, 4, 7, 9], level [1, 1, 2, 2, 3, 3, 4, 5, 4]ã€‚selectåªæ˜¯ç”¨æ¥è®¡ç®—levelç”¨çš„ï¼Œä¸”selectçš„é•¿åº¦å°±æ˜¯æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ã€‚

å¾—åˆ°levelåï¼Œé€†åºæ”¾å…¥ã€‚

>lower_bound ç®—æ³•è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ—[first, last)ä¸­çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå€¼valçš„ä½ç½®
>
>upper_bound ç®—æ³•è¿”å›ä¸€ä¸ªéé€’å‡åºåˆ—[first, last)ä¸­ç¬¬ä¸€ä¸ªå¤§äºvalçš„ä½ç½®

```
class Solution {
public:
    /**
     * retrun the longest increasing subsequence
     * @param arr intæ•´å‹vector the array
     * @return intæ•´å‹vector
     */
    
    vector<int> LIS(vector<int>& arr) {
        vector<int>select;  // æœ€é•¿ä¸´æ—¶åºåˆ—ï¼Œä¸æ˜¯è¾“å‡ºï¼ï¼ï¼
        vector<int>level(arr.size());  // level[i]è¡¨ç¤ºåˆ°è‡ªå·±ä¸ºæ­¢çš„æœ€é•¿ä¸Šå‡åºåˆ—çš„é•¿åº¦

        
        for(int i=0; i<arr.size(); i++){
            if(i==0 || arr[i]>select[select.size()-1]){
                select.push_back(arr[i]);
                level[i] = select.size();
            }
            else{
                // æ‰¾å‡ºç¬¬ä¸€ä¸ªå¤§äºç­‰äºarr[i]çš„ä½ç½®
                int index = lower_bound(select.begin(), select.end(), arr[i])-select.begin();
                select[index] = arr[i];
                level[i] = index+1;
            }
        }
        // selectçš„é•¿åº¦å°±æ˜¯æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦
        vector<int>res(select.size());
        // ä»åŸå§‹æ•°ç»„ä¸­é€†åºæ”¾å…¥
        for(int i=arr.size()-1, j=select.size(); i>=0; i--){
            if(level[i]==j){
                res[--j] = arr[i];
            }
        }
        return res;
    }
};
```





### <font color=red>Almost Increasing Subsequence å‡ ä¹ä¸Šå‡å­åºåˆ—</font>

https://codeforces.com/contest/1818/problem/C

è´ªå¿ƒ+dp

è´ªå¿ƒå°±æ˜¯ï¼Œé‡åˆ° â‰¥3 ä¸ªè¿ç»­ä¸‹é™çš„å­—ç¬¦ï¼Œå°±åˆ é™¤ä¸­é—´çš„å‡ ä¸ªï¼Œåªä¿ç•™ä¸¤å¤´ã€‚

ä¾‹å¦‚ï¼š

5, 4, 3 éœ€è¦åˆ é™¤ 4ï¼›

5, 4, 3, 2 éœ€è¦åˆ é™¤ 4, 3

æ‰€ä»¥å¯¹äº a\[i\] è¦æ£€æŸ¥å·¦å³ä¸¤è¾¹ if(a[i-1] >= a[i] && a[i] >= a[i+1])ï¼Œåˆ¤æ–­è¯¥ä½æ˜¯ä¸æ˜¯åº”è¯¥è¢«åˆ é™¤ã€‚

dp[i] è¡¨ç¤ºä»¥ i ä¸ºç»“å°¾åˆ é™¤çš„å…ƒç´ ä¸ªæ•°ã€‚

æ‰€ä»¥æœ€åçš„ç­”æ¡ˆåº”è¯¥æ˜¯ **len - è¢«åˆ é™¤çš„å…ƒç´ ä¸ªæ•°**ã€‚

å¯¹äº [l, r]ï¼Œç”±äº r+1 ä¸åœ¨èŒƒå›´å†…ï¼Œæ‰€ä»¥ r è‚¯å®šä¸ä¼šè¢«åˆ é™¤ï¼Œåº”è¯¥çœ‹å®ƒçš„å‰ä¸€ä½ dp[r-1]ï¼›è‡³äºä¸ºä»€ä¹ˆæ˜¯ dp[l]ï¼Œå‡å¦‚åœ¨å®Œæ•´å­—ç¬¦ä¸²é‡Œ l æ˜¯è¦è¢«åˆ é™¤çš„ï¼Œè™½ç„¶ l-1 å¹¶æ²¡æœ‰åœ¨èŒƒå›´å†…ï¼Œä½†æ˜¯ dp[r-1] å·²ç»é»˜è®¤æŠŠ l è¢«åˆ é™¤ç®—è¿›å»äº†ï¼Œæ‰€ä»¥å·¦è¾¹ç•Œåº”è¯¥æŠŠè‡ªå·±ä¹Ÿç®—è¿›å»åšæŠµæ¶ˆã€‚å³  (dp[r-1] - dp[l])

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

int main(){
    int n, m;
    while(cin>>n>>m){
        int a[n+1];
        int dp[n+1];  // è¾¹ç•Œ
        memset(dp, 0, sizeof(dp));
        for(int i=1; i<=n; i++){
            scanf("%d", &a[i]);
        }

        // å¦‚æœå‡ºç°é¢˜ç›®è¯´çš„xï¼Œyï¼Œzåºåˆ—ï¼Œé‚£ä¹ˆåªè¦åˆ å»yå°±è¡Œã€‚
        // å¦‚æœæ˜¯è¿ç»­çš„ w, x, y, z, ï¼Œå°±æ¯”å¦‚è¯´æ˜¯5 4 4 3ï¼Œé‚£ä¹ˆä»ç„¶æ˜¯åˆ å»ä¸­é—´çš„ä¸¤ä¸ªã€‚
        for(int i=2; i<=n-1; i++){
            if(a[i-1] >= a[i] && a[i] >= a[i+1]){
                dp[i] = dp[i-1] + 1;
            }
            else dp[i] = dp[i-1];
        }

        int l, r;
        for(int i = 0;i <m; i++){
            cin>>l >> r;
            int len = r-l+1;
            if(len <=2){
                cout<<len<<endl;
            }
            else{
                cout << len - (dp[r-1] - dp[l]) << endl;
            }
        }
    }

}
```





### <font color=purple>NC128 æ¥é›¨æ°´é—®é¢˜</font>

[lc]42.æ¥é›¨æ°´ https://leetcode.cn/problems/trapping-rain-water/

æˆ‘è§‰å¾—æ˜¯ä¸Šå‡ï¼ˆéä¸¥æ ¼ï¼‰å­åºåˆ—å’Œä¸‹é™å­åºåˆ—é—®é¢˜ã€‚ä½†æˆ‘ç›´æ¥ç”¨çš„æ¨¡æ‹Ÿã€‚

![æˆªå±2023-02-09 15.00.47](https://raw.githubusercontent.com/Lenvia/md-pic/master/uPic/%E6%88%AA%E5%B1%8F2023-02-09%2015.00.47.png)

ä¾‹å¦‚ï¼Œè¾“å…¥[3,1,2,<font color=red>5</font>,2,4]  

å¡«æ»¡é›¨æ°´åå˜æˆ [3, 3, 3, <font color=red>5</font>, 4, 4]

æ‰€ä»¥åªè¦æ‰¾åˆ°æœ€å¤§å€¼ï¼Œæœ€å¤§å€¼å·¦è¾¹éƒ½éä¸‹é™ï¼Œå³è¾¹çš„éä¸Šå‡ã€‚

```
if(arr[i]<arr[i-1]){  // å·¦è¾¹
  res += (arr[i-1]-arr[i]);
  arr[i] = arr[i-1];
}

....

if(arr[i]<arr[i+1]){  // å³è¾¹
	res += (arr[i+1]-arr[i]);
	arr[i] = arr[i+1];
}
```

æ³¨æ„ç­”æ¡ˆè¦ç”¨long long

æ³•ä¸€ï¼š

```
class Solution {
public:
    /**
     * max water
     * @param arr intæ•´å‹vector the array
     * @return longé•¿æ•´å‹
     */
    long long maxWater(vector<int>& arr) {
        if(arr.size()<=1) return 0;
        long long maxx, pos;
        maxx = -1; pos = -1;
        // æ‰¾æœ€å¤§å€¼å’Œæ‰€åœ¨çš„ä½ç½®
        for(int i=0; i<arr.size(); i++){
            if(arr[i]>maxx){
                maxx = arr[i];
                pos = i;
            }
        }
        long long res = 0;
        // åœ¨poså·¦è¾¹åº”è¯¥æ˜¯ä¸Šå‡ï¼ˆéä¸‹é™ï¼‰å­åºåˆ—ï¼Œå³è¾¹æ˜¯ä¸‹é™ï¼ˆéä¸Šå‡ï¼‰å­åºåˆ—
        for(int i=1; i<pos; i++){
            if(arr[i]<arr[i-1]){
                res += (arr[i-1]-arr[i]);
                arr[i] = arr[i-1];
            }
        }
        for(int i=arr.size()-2; i>pos; i--){
            if(arr[i]<arr[i+1]){
                res += (arr[i+1]-arr[i]);
                arr[i] = arr[i+1];
            }
        }
        return res;
    }
};
```

æ³•äºŒï¼šåŠ¨æ€è§„åˆ’

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656c7931683338386c6f643573376a3231393230676f74636a2e6a7067-20230504203835000.jpeg" alt="img" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f65366339643234656c7931683338386d677538396c6a3231357130706b676e732e6a7067.jpeg" alt="img" style="zoom:50%;" />

```
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if(n==0) return 0;

        int left[n];
        int right[n];

        left[0] = height[0];
        right[n-1] = height[n-1];

        for(int i=1; i<n; i++){
            left[i] = max(left[i-1], height[i]);
        }
        for(int i=n-2; i>=0; i--){
            right[i] = max(right[i+1], height[i]);
        }

        int ans = 0;
        for(int i=0; i<n; i++){
            ans += min(left[i], right[i]) - height[i];
        }
        return ans;
    }
};
```



æ³•ä¸‰ï¼šåŒæŒ‡é’ˆ

ä¸æ–­å‘å†…ç§»åŠ¨è¾ƒå°çš„æŒ‡é’ˆã€‚

```
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int l = 0;
        int r = height.size()-1;

        while(l<r){
            if(height[l] < height[r]){
                l++;
                if(height[l-1]-height[l] > 0){
                    res += (height[l-1] - height[l]);
                    height[l] = height[l-1];  // å¡«å……
                }                
            }
            else{
                r--;
                if(height[r+1]-height[r] > 0){
                    res += (height[r+1] - height[r]);
                    height[r] = height[r+1];
                }  
            }
        }
        return res;
    }
};
```







### NC7 ä¹°å–è‚¡ç¥¨çš„æœ€å¥½æ—¶æœº(ä¸€)

> ä½ å¯ä»¥ä¹°å…¥ä¸€æ¬¡è‚¡ç¥¨å’Œå–å‡ºä¸€æ¬¡è‚¡ç¥¨ï¼Œå¹¶éæ¯å¤©éƒ½å¯ä»¥ä¹°å…¥æˆ–å–å‡ºä¸€æ¬¡ï¼Œæ€»å…±åªèƒ½ä¹°å…¥å’Œå–å‡ºä¸€æ¬¡ï¼Œä¸”ä¹°å…¥å¿…é¡»åœ¨å–å‡ºçš„å‰é¢çš„æŸä¸€å¤©

å…¶å®ç”¨ä¸ç€dpï¼Œç›´æ¥æš´åŠ›å°±è¡Œã€‚ã€‚

æ–¹æ³•ä¸€ï¼šdp

dp[i] è¡¨ç¤ºä¸€å®šåœ¨iä½ç½®å–å‡ºã€‚ï¼ˆå¦‚æœå‰é¢æ²¡æœ‰ä¹°å…¥ï¼Œå³dp[i]=0ï¼Œå¯ä»¥å½“ä½œåœ¨iä¹°äº†åˆå–äº†ï¼‰

ä¾‹å¦‚ï¼Œè¾“å…¥ [8,9,2,5,4,7,1]

è®¡ç®—å¾—dp[1] = 1ï¼Œè¯´æ˜åœ¨9æ—¶å–å‡ºå¯ä»¥å¾—1ã€‚å¦‚æœåé¢çš„æ•°å­—å¤§äº9ï¼Œé‚£ç›´æ¥åŠ ä¸Šå·®å€¼ï¼Œæ²¡é—®é¢˜ã€‚

ä½†å¦‚æœåé¢çš„æ•°å­—å°äºå½“å‰ï¼Œæ¯”å¦‚9åé¢çš„2ã€‚å…ˆè®¡ç®— dp[i-1] + prices[i] - prices[i-1]ï¼Œçœ‹çœ‹ä»ç„¶åœ¨åŸæ¥çš„ä½ç½®ä¹°å…¥ï¼Œåœ¨å½“å‰ç‚¹å–å‡ºäºä¸äºã€‚å¦‚æœä¸äºï¼Œoké‚£è¿˜æœ‰åˆ©æ¶¦å¯ä»¥ç•™ç€ï¼›å¦‚æœäºäº†ï¼Œé‚£ä¸åœ¨åŸæ¥çš„ä½ç½®ä¹°å…¥äº†ï¼Œå°±åœ¨è‡ªå·±è¿™é‡Œä¹°ã€‚æ‰€ä»¥ dp[i] = max(0, dp[i-1] + prices[i] - prices[i-1]);

```
class Solution {
public:
    /**
     * 
     * @param prices intæ•´å‹vector 
     * @return intæ•´å‹
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<2) return 0;
        
        int maxx = 0;
        int dp[prices.size()];
        memset(dp, 0, sizeof(dp));
        
        for(int i=1; i<prices.size(); i++){
            if(prices[i]>=prices[i-1]){
                dp[i] = dp[i-1] + prices[i] - prices[i-1];
            }
            else{
                dp[i] = max(0, dp[i-1] + prices[i] - prices[i-1]);
            }
            maxx = max(maxx, dp[i]);
        }
        return maxx;
    }
};
```



æ–¹æ³•äºŒï¼šå¸¸è§„

æ¯å¤©è®¡ç®—å½“å¤©èƒ½è·å¾—çš„æœ€å¤§åˆ©æ¶¦ï¼Œæ›´æ–°æˆªæ­¢å½“å¤©çš„æœ€ä½ä»·ã€‚

```
class Solution {
public:
    /**
     * 
     * @param prices intæ•´å‹vector 
     * @return intæ•´å‹
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<2) return 0;
        
        int minx = 0x3ffffff;
        int res = -1;
        
        for(int i=0; i<prices.size(); i++){
            minx = min(minx, prices[i]);
            res = max(res, prices[i]-minx);
        }
        return res;
    }
};
```





### âš¡ï¸<font color=fuchsia>NC35 ç¼–è¾‘è·ç¦»(äºŒ)</font>

æœ€çŸ­ç¼–è¾‘è·ç¦»ã€‚

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²str1å’Œstr2ï¼Œå†ç»™å®šä¸‰ä¸ªæ•´æ•°icï¼Œdcå’Œrcï¼Œåˆ†åˆ«ä»£è¡¨æ’å…¥ã€åˆ é™¤å’Œæ›¿æ¢ä¸€ä¸ªå­—ç¬¦çš„ä»£ä»·ï¼Œè¯·è¾“å‡ºå°†str1ç¼–è¾‘æˆstr2çš„æœ€å°ä»£ä»·ã€‚

åŠ¨æ€è§„åˆ’ã€‚**dp\[i]\[j] è¡¨ç¤º åŸå§‹ä¸²str1\[0:i-1] ç¼–è¾‘æˆ str2\[0: j-1] çš„ä»£ä»·**ã€‚è¿™é‡Œæˆ‘å¯¹str1å’Œstr2å‰é¢insertäº†ä¸€ä¸ªç©ºæ ¼ï¼Œå¤„ç†ä¸€ä¸‹è¾¹ç•Œã€‚

æ‰€ä»¥å˜æˆäº† dp\[i]\[j] è¡¨ç¤º str1\[0:i] ç¼–è¾‘æˆ str2\[0: j] çš„ä»£ä»·ã€‚ å°±æ˜¯è¯´ï¼Œä¸ç®¡ä½ æ€ä¹ˆæ“ä½œï¼Œæ“ä½œå®Œä¹‹ååªå‰©ä¸‹str1çš„ i+1ä¹‹åçš„å­—ç¬¦ å’Œstr2çš„ j+1ä¹‹åçš„å­—ç¬¦ã€‚ä¸èƒ½æŠŠstr1çš„iæˆ–str2çš„jç•™åˆ°åé¢ã€‚

<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/68747470733a2f2f747661312e73696e61696d672e636e2f6c617267652f3030386933736b4e6c7931677a63653566376c78366a3331396d30726b6a766a2e6a7067.jpeg" alt="æˆªå±2022-02-14 01.20.38" style="zoom:50%;" />

è§£é‡Šä¸€ä¸‹ str1[i] != str2[j] æ—¶çš„æƒ…å†µï¼š

- æ’å…¥str2[j]: ï¼ˆå›¾ä¸­ <font color=deepskyblue>j</font> çš„ä½ç½®å†™é”™äº†ï¼Œåº”è¯¥åœ¨iåé¢ï¼‰
  - æ—¢ç„¶æ’å…¥ä¸€ä¸ªjå’Œstr2çš„jä½ç½®å¯¹é½äº†ï¼Œé‚£iå’‹åŠï¼Ÿè‚¯å®šæ˜¯è¦æ”¾åœ¨å‰é¢å’Œj-1å¯¹é½äº†ã€‚æ‰€ä»¥æ˜¯ dp\[i]\[j-1] + ic
- åˆ é™¤str1[i]ï¼š
  - ç¬¬iä½å¯¹ä¸é½æ˜¯å§ï¼Œçˆ·ä¸è¦äº†ã€‚è®©str2[j] å»å’Œ içš„å‰ä¸€ä½å¯¹é½å»ã€‚å°±æ˜¯ dp\[i-1]\[j] + dc
- æ›¿æ¢ï¼Œæ˜¾ç„¶ã€‚



```
class Solution {
public:
    /**
     * min edit cost
     * @param str1 stringå­—ç¬¦ä¸² the string
     * @param str2 stringå­—ç¬¦ä¸² the string
     * @param ic intæ•´å‹ insert cost
     * @param dc intæ•´å‹ delete cost
     * @param rc intæ•´å‹ replace cost
     * @return intæ•´å‹
     */
    int minEditCost(string str1, string str2, int ic, int dc, int rc) {
        int dp[str1.size()+1][str2.size()+1];  // dp[i][j] è¡¨ç¤ºstr1[0:i] å˜æˆ str2[0:j]çš„æœ€å°ç¼–è¾‘è·ç¦»
        memset(dp, 0, sizeof(dp));
        
        for(int i=0; i<str1.size()+1; i++) dp[i][0] = dc*i;  // åªèƒ½åˆ é™¤
        for(int j=0; j<str2.size()+1; j++) dp[0][j] = ic*j;  // åªèƒ½æ’å…¥
        
        // è¾¹ç•Œ
        str1.insert(0, " ");
        str2.insert(0, " ");
        
        for(int i=1; i<str1.size(); i++){
            for(int j=1; j<str2.size(); j++){
                if(str1[i]==str2[j]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] = min(min(dp[i][j-1]+ic, dp[i-1][j]+dc), dp[i-1][j-1] + rc);
                }
            }
        }
        return dp[str1.size()-1][str2.size()-1];
    }
};
```



å¯ä»¥çœ‹åˆ°åªåˆ©ç”¨äº†æœ¬å±‚å’Œä¸Šä¸€å±‚ã€‚

é‚£å†ä½¿ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–ã€‚æ³¨æ„ï¼dp\[i%2][0] æ˜¯ä¸åŒçš„ã€‚æ‰€ä»¥éœ€è¦æ”¾åœ¨å¾ªç¯é‡Œåˆå§‹åŒ–ã€‚

```
class Solution {
public:
    /**
     * min edit cost
     * @param str1 stringå­—ç¬¦ä¸² the string
     * @param str2 stringå­—ç¬¦ä¸² the string
     * @param ic intæ•´å‹ insert cost
     * @param dc intæ•´å‹ delete cost
     * @param rc intæ•´å‹ replace cost
     * @return intæ•´å‹
     */
    int minEditCost(string str1, string str2, int ic, int dc, int rc) {
        int dp[2][str2.size()+1];  // dp[i%2][j] è¡¨ç¤ºstr1[0:i] å˜æˆ str2[0:j]çš„æœ€å°ç¼–è¾‘è·ç¦»
        memset(dp, 0, sizeof(dp));
        
        // dp[i][0]ç­‰ä¼šåœ¨å¾ªç¯é‡Œåˆå§‹åŒ–
        for(int j=0; j<str2.size()+1; j++) dp[0][j] = ic*j;  // åªèƒ½æ’å…¥
        
        // è¾¹ç•Œ
        str1.insert(0, " ");
        str2.insert(0, " ");
        
        for(int i=1; i<str1.size(); i++){
            dp[i%2][0] = dc*i;
            for(int j=1; j<str2.size(); j++){
                if(str1[i]==str2[j]){
                    dp[i%2][j] = dp[(i-1)%2][j-1];
                }
                else{
                    dp[i%2][j] = min(min(dp[i%2][j-1]+ic, dp[(i-1)%2][j]+dc), dp[(i-1)%2][j-1] + rc);
                }
            }
        }
        return dp[(str1.size()-1)%2][str2.size()-1];
    }
};
```



### NC59 çŸ©é˜µçš„æœ€å°è·¯å¾„å’Œ

åŠ¨æ€è§„åˆ’æ°´é¢˜ï¼Œæ»šåŠ¨æ•°ç»„ä¼˜åŒ–ã€‚

æ³¨æ„è¾¹ç•Œçš„åˆå§‹åŒ–ï¼

```
class Solution {
public:
    /**
     * 
     * @param matrix intæ•´å‹vector<vector<>> the matrix
     * @return intæ•´å‹
     */
    int minPathSum(vector<vector<int> >& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        vector<vector<int>>dp(2, vector<int>(matrix[0].size(), 0));
        
        dp[0][0] = matrix[0][0];
        for(int j=1; j<matrix[0].size(); j++){
            dp[0][j] = dp[0][j-1] + matrix[0][j];
        }
        
        for(int i=1; i<matrix.size(); i++){
            dp[i%2][0] = dp[(i-1)%2][0] + matrix[i][0];  // åªèƒ½ä»ä¸Šè¾¹æ¥
            for(int j=1; j<matrix[0].size(); j++){
                dp[i%2][j] = min(dp[(i-1)%2][j], dp[i%2][j-1]) + matrix[i][j];
            }
        }
        return dp[(matrix.size()-1)%2][matrix[0].size()-1];
    }
};
```



### NC34 æ±‚è·¯å¾„

æ°´é¢˜åŠ¨æ€è§„åˆ’ã€‚m*næ–¹æ ¼

å¸¸è§„æ–¹æ³•å°±ä¸å†™å…¨äº†ï¼Œ

```
dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1];
```

æ—¶é—´å¤æ‚åº¦O(mn)ï¼Œç©ºé—´å¤æ‚åº¦O(mn)ï¼Œæ»šåŠ¨æ•°ç»„ä¼˜åŒ–åä¹Ÿä»ç„¶æœ‰O(n)

ç»„åˆæ•°å­¦æ³•ï¼š

ç”±äºåœ¨çŸ©é˜µä¸­æ²¡æœ‰éšœç¢ç‰©ï¼Œä»å·¦ä¸Šè§’ç§»åŠ¨åˆ°å³ä¸‹è§’ä¸€å…±è¦ç§»åŠ¨m+n-2æ¬¡ï¼Œå…¶ä¸­æœ‰m-1æ¬¡å‘ä¸‹ï¼Œn-1æ¬¡å‘å³ï¼Œå¯¹è¿™ä¸¤ç§æ“ä½œè¿›è¡Œç»„åˆã€‚å› æ­¤æœ€åå°±æ˜¯æ±‚$C_{m+n-2}^{m-1}$

æ—¶é—´å¤æ‚åº¦O(min(m, n))ï¼Œç©ºé—´å¤æ‚åº¦O(1)

```
int uniquePaths(int m, int n) {
    long long ret = 1;
    for (int x = n, y = 1; y < m; ++x, ++y) {
        //ç»„åˆå…¬å¼çš„å¾ªç¯æ±‚è§£
        ret = ret * x / y;
    }
    return ret;
}
```



### âš¡ï¸<font color=red>NC83 è¿ç»­å­æ•°ç»„çš„æœ€å¤§ä¹˜ç§¯</font>

æœ¬æ¥æˆ‘ä¸€å¼€å§‹æƒ³çš„æ˜¯å’Œè¿ç»­å­æ•°ç»„çš„å’Œå·®ä¸å¤šï¼Œä½†æ˜¯ä¹˜æ³•çš„è¯ï¼Œæœ‰è´Ÿæ•°å’Œ0ã€‚

ç‰¹åˆ«æ˜¯è´Ÿæ•°ã€‚

å‚è€ƒäº†é¢˜è§£ï¼Œ**å½“å‰ä½ç½®çš„æœ€å¤§ä¹˜ç§¯ï¼Œåªæ¥æºäºä¸‰ç§æƒ…å†µï¼šåªæœ‰è‡ªå·±ã€å‰ä¸€ä½çš„æœ€å¤§å€¼ä¸è‡ªå·±ç›¸ä¹˜**ï¼ˆæ¯”å¦‚å’Œå‰ä¸€ä½æœ€å¤§å€¼åŒå·æ—¶ï¼‰ã€å‰ä¸€ä½çš„æœ€å°å€¼ä¸è‡ªå·±ç›¸ä¹˜ï¼ˆæ¯”å¦‚å’Œå‰ä¸€ä½æœ€å°å€¼åŒå·ï¼Œå’Œæœ€å¤§å€¼å¼‚å·ï¼‰ã€‚

ç„¶åå› ä¸ºåªä½¿ç”¨å‰ä¸€ä½çš„ï¼Œå°±ä¸ç”¨å¼€æ•°ç»„äº†ï¼Œç›´æ¥ç”¨preè¿›è¡Œå¾ªç¯æ›´æ–°å‰ä¸€ä½çš„ä¿¡æ¯ã€‚

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     * 
     * @param nums intæ•´å‹vector 
     * @return intæ•´å‹
     */
    int maxProduct(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        
        int cur_max, cur_min, pre_max, pre_min;
        pre_max = nums[0]; pre_min = nums[0];
        int res = nums[0];
        
        for(int i=1; i<nums.size(); i++){
            // åæ­£ä¸€å…±åªæœ‰ä¸‰ä¸ªé€‰æ‹©
            cur_max = max(nums[i], max(pre_max*nums[i], pre_min*nums[i]));
            cur_min = min(nums[i], min(pre_max*nums[i], pre_min*nums[i]));
            res = max(res, cur_max);
            pre_max = cur_max;
            pre_min = cur_min;
        }
        
        return res;
        
    }
};
```



### ğŸ”¥âš¡ï¸<font color=fuchsia>NC135 ä¹°å–è‚¡ç¥¨çš„æœ€å¥½æ—¶æœº(ä¸‰)</font>

çŠ¶æ€å®šä¹‰ï¼šç¬¬ä¸€ç»´è¡¨ç¤ºäº¤æ˜“å¤©æ•°ï¼Œç¬¬äºŒç»´è¡¨ç¤ºäº¤æ˜“æ¬¡æ•°ï¼Œç¬¬ä¸‰ç»´è¡¨ç¤ºæ˜¯å¦æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆåˆ†æœªæŒæœ‰è‚¡ç¥¨å’ŒæŒæœ‰è‚¡ç¥¨ä¸¤ç§ï¼‰ã€‚

åˆå§‹åŒ–ï¼š

> é¦–å…ˆdp\[0]\[k]\[0] = 0; ç¬¬0å¤©æ— è®ºè¿›è¡Œå¤šå°‘æ¬¡äº¤æ˜“ï¼Œåªè¦ä¸æŒæœ‰å°±æ˜¯0
> dp\[0]\[k]\[1] = -prices[0];  ç¬¬0å¤©æ— è®ºè¿›è¡Œå¤šå°‘æ¬¡äº¤æ˜“ï¼ŒæŒæœ‰å°±æ˜¯-price[0]
> é‚£å¯¹äº dp\[i]\[0]\[0] å’Œ dp\[i]\[0]\[1] å‘¢ï¼Ÿ
> é¦–å…ˆï¼Œä¸ä¼šæœ‰ä»»ä½•k>0çš„çŠ¶æ€éœ€è¦ dp\[i]\[0]\[1]ï¼Œæ‰€ä»¥dp\[i]\[0]\[1]å¯éšæœºåˆå§‹åŒ–ï¼Œæ¯”å¦‚è®¾ä¸º0
> å¯¹äºdp\[i]\[0]\[0]ï¼Œä¸å°±æ˜¯ä¸€ç›´æ²¡æ“ä½œå˜›ï¼Œé‚£è‚¯å®šå°±æ˜¯0äº†



çŠ¶æ€è½¬ç§»ï¼š

å½“æŸä¸€å¤©ç¬¬kæ¬¡äº¤æ˜“ï¼Œå¹¶å¤„äºæœªæŒæœ‰è‚¡ç¥¨çŠ¶æ€æ—¶ï¼Œå…¶æœ€å¤§å€¼ï¼Œè¦ä¹ˆæ˜¯ä¹‹å‰æŸä¸€å¤©ç¬¬kæ¬¡äº¤æ˜“æœªæŒæœ‰è‚¡ç¥¨çŠ¶æ€çš„æœ€å¤§å€¼ï¼Œè¦ä¹ˆæ˜¯ä¹‹å‰æŸä¸€å¤©æŒæœ‰è‚¡ç¥¨çŠ¶æ€å–å‡ºå½“å¤©çš„è‚¡ç¥¨ï¼Œå³ $dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);$

å½“æŸä¸€å¤©ç¬¬kæ¬¡äº¤æ˜“ï¼Œå¹¶å¤„äºæŒæœ‰è‚¡ç¥¨çŠ¶æ€æ—¶ï¼Œå…¶æœ€å¤§å€¼ï¼Œè¦ä¹ˆæ˜¯ä¹‹å‰æŸä¸€å¤©ç¬¬kæ¬¡äº¤æ˜“æŒæœ‰è‚¡ç¥¨çŠ¶æ€çš„æœ€å¤§å€¼ï¼Œè¦ä¹ˆæ˜¯ä¹‹å‰æŸä¸€å¤©ç¬¬k-1æ¬¡äº¤æ˜“æœªæŒæœ‰è‚¡ç¥¨çŠ¶æ€ä¹°å…¥å½“å¤©çš„è‚¡ç¥¨ï¼ˆä¸èƒ½åŒæ—¶æŒæœ‰ä¸¤åªè‚¡ç¥¨ï¼‰ï¼Œå³$dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);$



```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     * ä¸¤æ¬¡äº¤æ˜“æ‰€èƒ½è·å¾—çš„æœ€å¤§æ”¶ç›Š
     * @param prices intæ•´å‹vector è‚¡ç¥¨æ¯ä¸€å¤©çš„ä»·æ ¼
     * @return intæ•´å‹
     */
    int maxProfit(vector<int>& prices) {
        if(prices.size()<=1) return 0;
        
        int len = prices.size();
        int maxk = 2;
        int dp[len][maxk+1][2];  // dp[i][k][0] è¡¨ç¤ºç¬¬iå¤©ï¼Œç¬¬kæ¬¡äº¤æ˜“ï¼Œä¸æŒæœ‰è‚¡ç¥¨çš„æ”¶ç›Šï¼›
        memset(dp, 0, sizeof(dp));
				// åˆå§‹åŒ–
        // é¦–å…ˆdp[0][k][0] = 0; ç¬¬0å¤©æ— è®ºè¿›è¡Œå¤šå°‘æ¬¡äº¤æ˜“ï¼Œåªè¦ä¸æŒæœ‰å°±æ˜¯0
        // dp[0][k][1] = -prices[0];  ç¬¬0å¤©æ— è®ºè¿›è¡Œå¤šå°‘æ¬¡äº¤æ˜“ï¼ŒæŒæœ‰å°±æ˜¯-price[0]
        // é‚£å¯¹äº dp[i][0][0] å’Œ dp[i][0][1] å‘¢ï¼Ÿ
        // é¦–å…ˆï¼Œä¸ä¼šæœ‰ä»»ä½•k>0çš„çŠ¶æ€éœ€è¦ dp[i][0][1]ï¼Œæ‰€ä»¥dp[i][0][1]å¯éšæœºåˆå§‹åŒ–ï¼Œæ¯”å¦‚è®¾ä¸º0
        // å¯¹äºdp[i][0][0]ï¼Œä¸å°±æ˜¯ä¸€ç›´æ²¡æ“ä½œå˜›ï¼Œé‚£è‚¯å®šå°±æ˜¯0äº†
        
        for(int i=0; i<len; i++){
            for(int k=1; k<=maxk; k++){
                if(i==0){
                    dp[i][k][0] = 0;  // ç¬¬0å¤©æ— è®ºè¿›è¡Œå¤šå°‘æ¬¡äº¤æ˜“ï¼Œåªè¦ä¸æŒæœ‰å°±æ˜¯0
                    dp[i][k][1] = -prices[i];
                }
                else{
                    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
                }
                
            }
        }
        return dp[len-1][2][0];
    }
};
```





### âš¡ï¸<font color=fuchsia>NC49 æœ€é•¿çš„æ‹¬å·å­ä¸²</font>

åŠ¨æ€è§„åˆ’éš¾é¢˜ã€‚

æˆ‘æœ¬æ¥æƒ³çš„æ˜¯æšä¸¾é•¿åº¦l ï¼Œæ¯æ¬¡ +=2ï¼Œè¿™æ ·çš„è¯ï¼Œæ¯æ¬¡åªè¦è€ƒè™‘å®ƒä¸Šä¸€å±‚çš„ä¸‰ç§æƒ…å†µï¼Œç»“æœæ®µé”™è¯¯ã€‚

æ ‡å‡†è§£æ³•æ˜¯ **dp[i] è¡¨ç¤ºä»¥ç¬¬iç»“å°¾çš„æœ€é•¿åˆæ ¼é•¿åº¦ï¼ˆiçš„å­—ç¬¦å¿…é¡»ç”¨ä¸Šï¼‰**

é‚£ä¹ˆåªè¦è€ƒè™‘i-1ä½çš„ä¸¤ç§æƒ…å†µå°±å¯ä»¥åŠ¨æ€è§„åˆ’äº†ã€‚

```
class Solution {
public:
    /**
     * 
     * @param s stringå­—ç¬¦ä¸² 
     * @return intæ•´å‹
     */
    int longestValidParentheses(string s) {
        int n = s.length();
        if(n<2) return 0;
        
        int dp[n];  // dp[i] è¡¨ç¤ºä»¥ç¬¬iç»“å°¾çš„æœ€é•¿åˆæ ¼é•¿åº¦ï¼ˆiçš„å­—ç¬¦å¿…é¡»ç”¨ä¸Šï¼‰
        memset(dp, 0, sizeof(dp));
        int ans = 0;
        
        for(int i=1; i<n; i++){
            if(s[i]==')'){  //  å¿…é¡»æ˜¯ ')'
                if(s[i-1] == '('){  // å¯ä»¥å’Œå®ƒå‰ä¸€ä½çš„ç›´æ¥åŒ¹é…
                    dp[i] = dp[i-2] + 2;
                }
                else{  // s[i-1] == ')'
                    // è¿™æ—¶å€™å­—ç¬¦ä¸²å¿…é¡»æ˜¯ xxx ( ( .... ) )ï¼Œæ³¨ï¼šå†…æ‹¬å·å¯èƒ½æ²¡æœ‰ï¼Œå³é•¿åº¦ä¸º0
                    // å³è¾¹çš„ä¸¤å±‚æ‹¬å·ä¸€å®šæ˜¯å…¨åŒ¹é…çš„ï¼Œæ‰€ä»¥å†…å±‚æ‹¬å·çš„é•¿åº¦å°±æ˜¯ dp[i-1]
                    if(i-dp[i-1]-1 >=0 && s[i-dp[i-1]-1] == '('){  // é¦–å…ˆä¿è¯æœ€å¤–å±‚æ‹¬å·åŒ¹é…
                        // xxxçš„å³è¾¹ç•Œå°±æ˜¯ i-dp[i-1]-2
                        dp[i] = dp[i-1] + 2;
                        int r = i-dp[i-1]-2;
                        if(r>=0)
                            dp[i] += dp[r];
                    }
                    
                }
                ans = max(ans, dp[i]);
            }
        }
        return ans;
    }
};
```



æ–¹æ³•äºŒï¼šæ ˆ

å‚è€ƒ[å®˜æ–¹é¢˜è§£](https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/)

å§‹ç»ˆä¿æŒæ ˆåº•å…ƒç´ ä¸ºå½“å‰å·²ç»éå†è¿‡çš„å…ƒç´ ä¸­ã€Œæœ€åä¸€ä¸ªæ²¡æœ‰è¢«åŒ¹é…çš„å³æ‹¬å·çš„ä¸‹æ ‡ã€ï¼Œè¿™æ ·çš„åšæ³•ä¸»è¦æ˜¯è€ƒè™‘äº†è¾¹ç•Œæ¡ä»¶çš„å¤„ç†ï¼Œæ ˆé‡Œå…¶ä»–å…ƒç´ ç»´æŠ¤å·¦æ‹¬å·çš„ä¸‹æ ‡ï¼š

- å¯¹äºé‡åˆ°çš„æ¯ä¸ª '(' ï¼Œæˆ‘ä»¬å°†å®ƒçš„ä¸‹æ ‡æ”¾å…¥æ ˆä¸­
- å¯¹äºé‡åˆ°çš„æ¯ä¸ª ')' ï¼Œæˆ‘ä»¬å…ˆå¼¹å‡ºæ ˆé¡¶å…ƒç´ è¡¨ç¤ºåŒ¹é…äº†å½“å‰å³æ‹¬å·ï¼š
  - å¦‚æœæ ˆä¸ºç©ºï¼Œè¯´æ˜å½“å‰çš„å³æ‹¬å·ä¸ºæ²¡æœ‰è¢«åŒ¹é…çš„å³æ‹¬å·ï¼Œæˆ‘ä»¬å°†å…¶ä¸‹æ ‡æ”¾å…¥æ ˆä¸­æ¥æ›´æ–°æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ã€Œæœ€åä¸€ä¸ªæ²¡æœ‰è¢«åŒ¹é…çš„å³æ‹¬å·çš„ä¸‹æ ‡ã€
  - å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œå½“å‰å³æ‹¬å·çš„ä¸‹æ ‡å‡å»æ ˆé¡¶å…ƒç´ å³ä¸ºã€Œä»¥è¯¥å³æ‹¬å·ä¸ºç»“å°¾çš„æœ€é•¿æœ‰æ•ˆæ‹¬å·çš„é•¿åº¦ã€



æˆ‘è¿›ä¸€æ­¥åˆ†æä¸€ä¸‹ï¼š

å½“é‡åˆ°ä¸€ä¸ªå³æ‹¬å·æ—¶ï¼Œæ ˆåªä¼šæœ‰ä»¥ä¸‹ä¸‰ç§æƒ…å†µï¼š

1. æ ˆé¡¶ä¸º-1
2. æ ˆé¡¶æ˜¯æœ€è¿‘çš„**å·¦æ‹¬å·**çš„ä¸‹æ ‡
3. æ ˆé¡¶æ˜¯æœ€åä¸€ä¸ªæ²¡æœ‰è¢«åŒ¹é…çš„**å³æ‹¬å·**ä¸‹æ ‡

æ‰§è¡Œ st.pop()

å‰ä¸‰ç§æƒ…å†µå˜ä¸ºï¼š

1. æ ˆç©ºã€‚ï¼ˆå³-1è¢«å¼¹å‡ºï¼Œæ­¤åå³æ‹¬å·ä¸‹æ ‡è¢«æ”¾å…¥ï¼‰
2. æ ˆä¸ç©ºï¼Œå¯èƒ½æ˜¯ä»»æ„æƒ…å†µï¼ˆ **-1ã€å·¦æ‹¬å·ã€å³æ‹¬å·**ï¼‰
3. æ ˆç©ºã€‚ï¼ˆè‚¯å®šä¸æ˜¯å·¦æ‹¬å·ï¼Œå¦‚æœæ˜¯é‚£æ—©å°±å’Œåˆšå¼¹å‡ºçš„å³æ‹¬å·åŒ¹é…äº†ï¼›ç”±1çŸ¥ï¼Œåˆšå¼¹å‡ºçš„æ˜¯å³æ‹¬å·ï¼Œæ‰€ä»¥ä¹‹å‰ä¸å¯èƒ½å†æœ‰-1ï¼›ç»å¯¹ä¸å¯èƒ½æœ‰å³æ‹¬å·ï¼Œç»“åˆæœ¬æƒ…å†µå³æ‹¬å·çš„æ›¿ä»£æ€§ï¼‰

æˆ‘ä»¬åœ¨æ ˆä¸ç©ºçš„æ—¶å€™æ‰ä¼šè®¡ç®—é•¿åº¦ã€‚

å¯¹äºç¬¬2ç§æƒ…å†µï¼Œå› ä¸ºåˆšå¼¹å‡ºçš„æ˜¯å·¦æ‹¬å·ï¼Œæ‰€ä»¥ç›´æ¥ä¸æ ˆé¡¶è®¡ç®—å°±è¡Œäº†ã€‚

å¯¹äºç¬¬3ç§æƒ…å†µï¼Œæ ˆç©ºï¼ŒæŠŠè‡ªå·±æ”¾è¿›å»ã€‚ç›¸å½“äºåˆ·æ–°äº†æœ€åä¸€ä¸ªæ²¡æœ‰è¢«åŒ¹é…çš„å³æ‹¬å·çš„ä¸‹æ ‡

```
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int>st;

        if(s.length() <=1 ) return 0;
        // å§‹ç»ˆä¿æŒæ ˆåº•å…ƒç´ ä¸ºå½“å‰å·²ç»éå†è¿‡çš„å…ƒç´ ä¸­ã€Œæœ€åä¸€ä¸ªæ²¡æœ‰è¢«åŒ¹é…çš„å³æ‹¬å·çš„ä¸‹æ ‡ã€
        // è¿™æ ·çš„åšæ³•ä¸»è¦æ˜¯è€ƒè™‘äº†è¾¹ç•Œæ¡ä»¶çš„å¤„ç†ï¼Œæ ˆé‡Œå…¶ä»–å…ƒç´ ç»´æŠ¤å·¦æ‹¬å·çš„ä¸‹æ ‡
        st.push(-1);

        int res = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i]=='('){
                st.push(i);
            }
            else{
                st.pop();
                if(st.empty()){
                    // æŠŠæ²¡åŒ¹é…ä¸Šçš„å³æ‹¬å·ä¸‹æ ‡æ”¾è¿›å»
                    st.push(i);
                }
                else {
                    res = max(res, i - st.top());
                }
            }
        }
        return res;
    }
};
```





### [lc]221. æœ€å¤§æ­£æ–¹å½¢

åœ¨ä¸€ä¸ªç”± `'0'` å’Œ `'1'` ç»„æˆçš„äºŒç»´çŸ©é˜µå†…ï¼Œæ‰¾åˆ°åªåŒ…å« `'1'` çš„æœ€å¤§æ­£æ–¹å½¢ï¼Œå¹¶è¿”å›å…¶é¢ç§¯ã€‚

https://leetcode.cn/problems/maximal-square/solutions/234964/zui-da-zheng-fang-xing-by-leetcode-solution/



å¦‚æœè¯¥ä½ç½®çš„å€¼æ˜¯ 0ï¼Œåˆ™ dp(i,j)=0ï¼Œå› ä¸ºå½“å‰ä½ç½®ä¸å¯èƒ½åœ¨ç”± 1 ç»„æˆçš„æ­£æ–¹å½¢ä¸­ï¼›

å¦‚æœè¯¥ä½ç½®çš„å€¼æ˜¯ 1ï¼Œåˆ™ dp(i,j) çš„å€¼ç”±å…¶ä¸Šæ–¹ã€å·¦æ–¹å’Œå·¦ä¸Šæ–¹çš„ä¸‰ä¸ªç›¸é‚»ä½ç½®çš„ dp å€¼å†³å®šã€‚å…·ä½“è€Œè¨€ï¼Œå½“å‰ä½ç½®çš„å…ƒç´ å€¼ç­‰äºä¸‰ä¸ªç›¸é‚»ä½ç½®çš„å…ƒç´ ä¸­çš„æœ€å°å€¼åŠ 1ã€‚
$$
d p(i, j)=\min (d p(i-1, j), d p(i-1, j-1), d p(i, j-1))+1
$$


<img src="https://cdn.jsdelivr.net/gh/Lenvia/md-pic@master/uPic/%E6%88%AA%E5%B1%8F2023-02-27%2001.17.03.png" alt="æˆªå±2023-02-27 01.17.03" style="zoom:50%;" />

å…³äºdpçš„æ„ä¹‰ï¼Œå¯ä»¥çœ‹è¿™ç¯‡

https://leetcode.cn/problems/count-square-submatrices-with-all-ones/solutions/101706/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/



```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size()==0)
            return 0;
        int m = matrix.size();
        int n = matrix[0].size();

        int dp[m][n];
        int maxx = 0;
        memset(dp, 0, sizeof(dp));

        for(int i = 0; i<m; i++){
            for(int j=0; j<n; j++){
                if(matrix[i][j] == '1'){
                    if(i==0 || j==0)
                        dp[i][j] = 1;
                    else
                        dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                    maxx = max(maxx, dp[i][j]);
                }
            }
        }
        return maxx * maxx;
    }
};
```





### âš¡ï¸âš¡ï¸<font color=fuchisa>ã€çŠ¶æ€å‹ç¼©ã€‘[lc]1755 æœ€æ¥è¿‘ç›®æ ‡å€¼çš„å­åºåˆ—å’Œ</font>

ä» `nums` ä¸­é€‰å‡ºä¸€ä¸ªå­åºåˆ—ï¼Œä½¿å­åºåˆ—å…ƒç´ æ€»å’Œæœ€æ¥è¿‘ `goal` ã€‚

> **ç›®æ ‡å€¼ä¸æ˜ç¡®**ï¼Œå®¹é‡ä¸çŸ¥é“ï¼Œä¸èƒ½ç”¨èƒŒåŒ…ï¼Œåªèƒ½æšä¸¾å­é›†çš„å’Œã€‚
>
> åªèƒ½äºŒåˆ†æ‹†æ•°ç»„æ¥é™ä½å¤æ‚åº¦ï¼Œç„¶åæšä¸¾å­æ•°ç»„çš„å­é›†çš„å’Œï¼Œæœ€åç”¨åŒæŒ‡é’ˆæŒ‡å‘ä¸¤ä¸ªå­é›†å’Œçš„å…ƒç´ ï¼Œä¸æ–­é€¼è¿‘ç›®æ ‡å€¼ã€‚
>
> æœ‰äººçœ‹åˆ°è¿™é‡Œå¯èƒ½è§‰å¾—æ˜¯ä¸æ˜¯å†™é”™äº†ï¼Œè¿™é¢˜é¢˜ç›®å·²ç»ç»™å‡ºäº†ç›®æ ‡å€¼ï¼Œä¸ºä»€ä¹ˆè¿˜è¯´æ˜¯ç›®æ ‡å€¼ä¸æ˜ç¡®çš„å‘¢ï¼Ÿ åŸå› åœ¨äºï¼Œé¢˜ç›®ç»™çš„targetä¸æ˜¯æˆ‘ä»¬æœ€åè¦ç»„åˆçš„ç›®æ ‡å€¼ï¼Œé¢˜ç›®è¦æˆ‘ä»¬æ±‚çš„æ˜¯minçš„æœ€å°å€¼ï¼Œè¿™é‡Œçš„æœ€å°å€¼æˆ‘ä»¬åœ¨è§£é¢˜ä¹‹å‰æ˜¯ä¸çŸ¥é“çš„ã€‚



```
class Solution {
public:
    int minAbsDifference(vector<int>& nums, int goal) {
        int n = nums.size();
        int ln = n/2;
        // æ‹†åˆ†æ•°ç»„
        vector<int>lvec = {nums.begin(), nums.begin() + ln};
        vector<int>rvec = {nums.begin()+ ln, nums.end()};

        int rn = rvec.size();

        int lcnt = 1<<ln;  // çŠ¶æ€ä¸ªæ•°
        int ldp[lcnt];  // ldpæ˜¯åŸæ•°ç»„å‰åŠéƒ¨åˆ†çš„å­æ•°ç»„çš„é›†åˆ
        ldp[0] = 0;

        int rcnt = 1<<rn;
        int rdp[rcnt];
        rdp[0] = 0;

        
        int id;
        for(int i=1; i<lcnt; i++){
            for(int j=0; j<ln; j++){
               id = 1<<j;
               if(id & i){  // ldp[i]å¯ä»¥æœ‰å¤šä¸ªä¸Šä¸ªçŠ¶æ€ï¼Œæˆ‘ä»¬åªè¦é€‰åˆ°ä¸€ä¸ªå°±è¡Œäº†ï¼Œéƒ½æ˜¯ä¸€æ ·çš„
                   ldp[i] = ldp[i-id] + lvec[j];
                   break;
               } 
            }
        }
        for(int i=1; i<rcnt; i++){
            for(int j=0; j<rn; j++){
               id = 1<<j;
               if(id & i){
                   rdp[i] = rdp[i-id] + rvec[j];
                   break;
               }
            }
        }
        sort(ldp, ldp+lcnt);
        sort(rdp, rdp+rcnt);

        int target = 0x7ffffff;

        // ä»…åŸæ•°ç»„å‰åŠéƒ¨åˆ†å­åºåˆ—çš„å’Œ
        int index1 = lower_bound(ldp, ldp+lcnt, goal) - ldp;
        if(index1 == lcnt){
            target = abs(ldp[lcnt-1] - goal);
        }
        else if(index1 == 0){
            target = abs(ldp[0] - goal);
        }
        else{
            target = min(abs(ldp[index1] - goal), abs(ldp[index1-1] - goal));
        }
        
        // ä»…åŸæ•°ç»„ååŠéƒ¨åˆ†å­åºåˆ—çš„å’Œ
        int index2 = lower_bound(rdp, rdp+rcnt, goal) - rdp;
        if(index2 == rcnt){
            target = min(target, abs(rdp[rcnt-1] - goal));
        }
        else if(index2 == 0){
            target = min(target, abs(rdp[0] - goal));
        }
        else{
            target = min(target, min(abs(rdp[index2] - goal), abs(rdp[index2-1] - goal)));
        }


        // ä»åŸæ•°ç»„å‰åŠéƒ¨åˆ†å–ä¸€ä¸ªå’Œï¼Œä»ååŠéƒ¨åˆ†å–ä¸€ä¸ªå’Œï¼Œç„¶åæƒ³åŠ 
        int i = 0, j = rcnt - 1;
        while (i < lcnt && j >= 0) {
            int s = ldp[i] + rdp[j];
            
            target = min(target, abs(goal - s));
            if (s > goal) {
                j--;
            } else {
                i++;
            }
        }


        return target;

    }
};
```





## å­—ç¬¦ä¸²

### <font color=purple>NC55 æœ€é•¿å…¬å…±å‰ç¼€</font>

https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=188&&tqId=38627&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

çºµå‘æ‰«æ

```
class Solution {
public:
    /**
     * 
     * @param strs stringå­—ç¬¦ä¸²vector 
     * @return stringå­—ç¬¦ä¸²
     */
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size()==0)
            return "";
        // çºµå‘æ‰«æ
        for(int j=0; j<strs[0].size(); j++){
            for(int i=0; i<strs.size(); i++){
                // å¦‚æœstrs[i]çš„ç¬¬jä½è¶Šç•Œ æˆ– å¦‚æœç¬¬jä½ä¸ç›¸ç­‰
                if(j==strs[i].size() || strs[0][j] != strs[i][j])
                    return strs[0].substr(0, j);
            }
        }
        return strs[0];
    }
};
```



### âš¡ï¸<font color=fuchsia>NC17 æœ€é•¿å›æ–‡å­ä¸²</font>

**Manacher**ç®—æ³•

æš´åŠ›æ–¹æ³•å°±æ˜¯ å¯¹äºæ¯ä¸ªä½ç½®ï¼Œå…ˆè®¾ç½®å»¶ä¼¸é•¿åº¦ p[i] = 1ï¼Œç„¶åçœ‹ s[i-p[i]] æ˜¯å¦ç­‰äº s[i+p[i]]ï¼Œä¸æ–­æ‰©å¤§p[i]ã€‚

Manacheræ–¹æ³•å°±æ˜¯å·æ‡’ï¼Œå³p[i] çš„åˆå§‹åŒ–ã€‚é‡ç‚¹æ˜¯å…³äºmx å’Œ id çš„è®¾ç½®ã€‚

```
int mx = 0;  // å½“å‰æœ€å³ä½ç½®
int id = -1;  // è¾¾åˆ°æœ€å³ä½ç½®æ—¶çš„ä¸­å¿ƒ
// è®¾ç½®mxå’Œidï¼Œæ„æ€æ˜¯å¯ä»¥ä¿è¯ [2id-mx, mx] æ˜¯å¯¹ç§°çš„

...

if(mx>i){  // æ­¤æ—¶çš„æ’åˆ—é¡ºåºæ˜¯  2id-mx, ..., 2id-i, ..., id, ..., i, ..., mx
    // æˆ‘ä»¬æƒ³çœ‹çœ‹ iå…³äº id çš„å¯¹ç§°ç‚¹ 2id-i çš„å¯¹ç§°æƒ…å†µ
    // [i, mx]è¿™æ®µç›¸å½“äº [2id-mx, 2id-i]è¿™æ®µå…³äº id å¯¹ç§°
    // æ‰€ä»¥å°±çœ‹ 2*id-i è¿™ç‚¹çš„å»¶ä¼¸é•¿åº¦ å’Œ å®ƒåˆ°è¾¹ç•Œ 2id-mx çš„è·ç¦»å¤§å°äº†ï¼Œé€‰å°çš„
    p[i] = min(p[2*id-i], mx-i);
}
```

å®Œæ•´ä»£ç ï¼š

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     * 
     * @param A stringå­—ç¬¦ä¸² 
     * @return intæ•´å‹
     */
    const static int MAXN = 1001;
    int p[2*MAXN+3];
    
    
    int Manacher(string newStr){
        int maxL = -1;  // æœ€é•¿å›æ–‡å­ä¸²é•¿åº¦
        int mx = 0;  // å½“å‰æœ€å³ä½ç½®
        int id = -1;  // è¾¾åˆ°æœ€å³ä½ç½®æ—¶çš„ä¸­å¿ƒ
        // è®¾ç½®mxå’Œidï¼Œæ„æ€æ˜¯å¯ä»¥ä¿è¯ [2id-mx, mx] æ˜¯å¯¹ç§°çš„
        for(int i=1; i<newStr.length(); i++){
            if(mx>i){  // æ­¤æ—¶çš„æ’åˆ—é¡ºåºæ˜¯  2id-mx, ..., 2id-i, ..., id, ..., i, ..., mx
                // æˆ‘ä»¬æƒ³çœ‹çœ‹ iå…³äº id çš„å¯¹ç§°ç‚¹ 2id-i çš„å¯¹ç§°æƒ…å†µ
                // [i, mx]è¿™æ®µç›¸å½“äº [2id-mx, 2id-i]è¿™æ®µå…³äº id å¯¹ç§°
                // æ‰€ä»¥å°±çœ‹ 2*id-i è¿™ç‚¹çš„å»¶ä¼¸é•¿åº¦ å’Œ å®ƒåˆ°è¾¹ç•Œ 2id-mx çš„è·ç¦»å¤§å°äº†ï¼Œé€‰å°çš„
                p[i] = min(p[2*id-i], mx-i);
            }
            else p[i] = 1;
            while(newStr[i-p[i]]==newStr[i+p[i]])
                p[i]++;
            if(mx< i+p[i]){
                id = i;
                mx = i+p[i];
            }
            maxL = max(maxL, p[i]-1);  // å‡1çš„åŸå› ï¼Œè‡ªå·±ç”»ç€çœ‹å°±çŸ¥é“äº†
        }
        return maxL;
    }
    
    int getLongestPalindrome(string A) {
        int len = A.length();
        // åˆå§‹åŒ–
        string newStr(2*len+3, '#');
        int newLen = newStr.length();
        newStr[0] = '$'; newStr[newLen-1] = '*';
        for(int i=0, j=2; i<A.length(); i++, j+=2){
            newStr[j] = A[i];
        }  // ä¾‹å¦‚ A = "abcbc"ï¼Œåˆ™newStr = "$#a#b#c#b#c#*"
        fill(p, p+newLen, 1);
        
        // Manacherè¿”å›çš„æ˜¯æ’å…¥åˆ†éš”ç¬¦åçš„å»¶ä¼¸é•¿åº¦ï¼Œæ‰€ä»¥æœ€ç»ˆè¿”å›åº”è¯¥é™¤ä»¥2
        return Manacher(newStr);
        
    }
};
```



ï¼ˆå¦‚æœéœ€è¦å†™æ•´ä¸ªç¨‹åºçš„ä»£ç ï¼Œç”¨è¿™ä¸ªï¼‰

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string.h>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;
const int MAXN = 110005;
int p[MAXN*2];
char s[MAXN*2];
string str;
string newStr;

/*
    newStrçš„æ„æˆä¸ä»…ä»…æ˜¯åŠ ä¸ª# åº”è¯¥ç»™åŸä¸²åŠ å®Œ#åï¼Œå†åœ¨é¦–å°¾åŠ ä¸Š ä¸ä¸€æ · çš„ ä¸¤ä¸ª ç¬¦å· æ¯”å¦‚ str = 12321
    newStr = $#1#2#3#2#1#* å¦‚æœé¦–å°¾ä¸€æ ·ï¼Œä¼šå‡ºé”™!!!!!
*/
void init(){
    fill(p, p+MAXN, 1);
    //åœ¨è¿™é‡Œ newStråˆ«æ‰‹è´±å‰é¢å†™ä¸ªstringï¼Œè€Œä¸”newStrçš„â»“åº¦æ˜¯2*str.length()+3
    newStr = string(2*str.length()+3, '#');
    newStr[0] = '$';
    newStr[newStr.length()-1] = '*'; //åœ¨strçš„æ¯ä¸ªå­—ç¬¦åéƒ½åŠ ä¸ªâ€œ#â€ï¼Œå¾—åˆ°æ–°å­—ç¬¦ä¸²newStr
    for(int i=0, j=2; i<str.length(); i++, j+=2){
        newStr[j] = str[i];
    }
}
int Manacher(){
    init();
    int maxL = -1; //æœ€å¤§å›æ–‡â»“åº¦
    int id = -1; //å½“å‰ä½¿mxè¾¾åˆ°å°½å¯èƒ½å³è¾¹æ—¶çš„å›æ–‡ä¸­å¿ƒ
    int mx = 0;
    //æœ«å°¾è¿˜æœ‰ä¸ª#ï¼Œä¸è¦æ”¾è¿›æ¥
    for(int i=1; i<newStr.length(); i++){
        if(mx>i){ //å¦‚æœä¹‹å‰çš„ä¸­å¿ƒidçš„æœ€å¤§å»¶å±•ä½ç½®è¶…è¿‡äº†iï¼Œé‚£ä¹ˆçœ‹çœ‹å¯ä¸å¯ä»¥ç»™p[i]èµ‹ ä¸€ä¸ªæœ€å°å€¼ï¼Œçœå»ä¸€äº›è®¡ç®—
            /*
            p[2*id-i]æ˜¯iå…³äºidçš„å¯¹ç§°ç‚¹çš„å»¶ä¼¸åŠå¾„ã€‚ mx-iæ˜¯mxä¸içš„è·ç¦»ï¼ŒåŒæ—¶ä¹Ÿæ˜¯mx
            å…³äºidçš„å¯¹ç§°ç‚¹åˆ° iå…³äºidçš„å¯¹ç§°ç‚¹çš„è·ç¦»
            
            å¦‚æœ p[2*id-i]>mx-iï¼Œè¯´æ˜içš„å¯¹ç§°ç‚¹jçš„åŠå¾„æ˜¯å¤§çš„ï¼Œä½†æ˜¯æˆ‘ä»¬ç°åœ¨æœ€å¤šåªèƒ½
            ä¿è¯[mxå¯¹ç§°ç‚¹ï¼Œmx]æ˜¯å¯¹ç§°çš„ï¼Œæ‰€ä»¥åªèƒ½å…ˆè®©p[i]ç­‰äºmx-i
            å¦‚æœ p[2*id-i]<mx-iï¼Œè¯´æ˜jçš„èŒƒå›´è¿˜æ²¡è¶…è¿‡idçš„èŒƒå›´ï¼Œé‚£ç¨å¾®ä¸€æƒ³å°±æ˜ç™½äº†ï¼Œ
            içš„åŠå¾„å°±æ˜¯jçš„åŠå¾„ã€‚ */
            p[i] = min(p[2*id-i], mx-i);
        }
        else p[i] = 1; //å¦åˆ™æ²¡æœ‰ç®€ä¾¿æ–¹æ³•ï¼ŒåŠå¾„åªèƒ½ä»1å¼€å§‹æœäº†
        while(newStr[i-p[i]] == newStr[i+p[i]]){ //ä»ä¸Šé¢å·²ç»é¢„èµ‹å€¼çš„åŠå¾„ç»§ç»­å¾€ä¸¤è¾¹å¯»æ‰¾
            cout<<newStr[i]<<" "<<p[i]<<" "<<newStr[i-p[i]]<<" "<<newStr[i+p[i]]<<endl;
            p[i]++;
        }
        if(mx< i+p[i]){ //å¦‚æœå½“å‰çš„æœ€å³èŒƒå›´è¶…è¿‡äº†mxï¼Œé‚£ä¹ˆæ›´æ–°mxã€‚ å› ä¸ºmxå°½å¯èƒ½çš„è¿œ æˆ‘ä»¬æ‰èƒ½æ›´å®¹æ˜“å·æ‡’ã€‚
            id = i;
            mx = i+p[i];
            
        }
        maxL = max(maxL, p[i]-1);
    }
    return maxL;
}

int main(){
    while(scanf("%s",s)!=EOF){ //ç”¨å­—ç¬¦æ•°ç»„è¾“å…¥!!!!
        str = s;
        int maxL = -1;
        maxL = Manacher();
        cout<<maxL<<endl;
    }
}


```



åŠ¨æ€è§„åˆ’ç®—æ³•

```
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.length()<2)
            return s;
        
        int len = s.length();
        int maxLen = 1;  // å¦‚æœé•¿åº¦å¤§äº2ï¼Œé‚£ä¹ˆå›æ–‡å­ä¸²é•¿åº¦è‡³å°‘ä¸º1.
        int startIndex = 0;
        
        bool dp[len+1][len+1];  // dp[i][j] è¡¨ç¤º s[i]åˆ°s[j]æ˜¯ä¸æ˜¯å›æ–‡å­ä¸²
        memset(dp, false, sizeof(dp));

        for(int i=0; i<len; i++)
            dp[i][i] = true;

        for(int l=2; l<=len; l++){  // å­ä¸²çš„é•¿åº¦ä»å°åˆ°å¤§
            for(int i=0; i<len; i++){  // æ¯æ¬¡ä»æœ€å¼€å¤´å¼€å§‹
                int j = i+l-1;  // å­ä¸²çš„æœ«ç«¯
                if(j>=len)  // è¶Šç•Œ
                    continue;
                if(s[i]!=s[j]){  // å­ä¸² s[i]~s[j]è‚¯å®šä¸æ˜¯å›æ–‡å­ä¸²
                    dp[i][j] = false;
                }
                else{
                    if(l<=2)
                        dp[i][j] = true;
                    else{  // å› ä¸ºs[i+1]~s[j-1]çš„é•¿åº¦æ›´å°ï¼Œæ‰€ä»¥åœ¨ä¹‹å‰å°±è®¡ç®—è¿‡äº†
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                if(dp[i][j] && l>maxLen){  // è®°å½•é•¿åº¦å’Œèµ·å§‹ä¸‹æ ‡
                    maxLen = l;
                    startIndex = i;
                }
            }
        }

        return s.substr(startIndex, maxLen);
    }
};
```



### <font color=purple>NC121 å­—ç¬¦ä¸²çš„æ’åˆ—</font>

æ–¹æ³•ä¸€ï¼šæŠ•æœºå–å·§ã€‚ç”¨äº†`<algorithm>`ä¸­çš„ next_permutation()

```
class Solution {
public:
    
    // bool next_permutation( iterator start, iterator end);
    // next_permutation()å‡½æ•°åŠŸèƒ½æ˜¯è¾“å‡ºå…¨éƒ¨æ¯”å½“å‰æ’åˆ—å¤§çš„æ’åˆ—ã€‚é¡ºåºæ˜¯ä»å°åˆ°å¤§ã€‚
    vector<string> Permutation(string str) {
        vector<string>res;
        if(str.length()==0) return res;

        string first = str;
        do{
            next_permutation(str.begin(), str.end());
            res.push_back(str);
        }while(str!=first);
        
        
        return res;
    }
};
```



æ–¹æ³•äºŒï¼šdfs+set

```
class Solution {
public:
    void perm(int pos, string s, set<string> &ret) {
        if (pos+1 == s.length()) {
            ret.insert(s);
            return;
        }
        // forå¾ªç¯å’Œswapçš„å«ä¹‰ï¼šå¯¹äºâ€œABCâ€ï¼Œ
        // ç¬¬ä¸€æ¬¡'A' ä¸ 'A'äº¤æ¢ï¼Œå­—ç¬¦ä¸²ä¸º"ABC", posä¸º0ï¼Œ ç›¸å½“äºå›ºå®š'A'
        // ç¬¬äºŒæ¬¡'A' ä¸ 'B'äº¤æ¢ï¼Œå­—ç¬¦ä¸²ä¸º"BAC", posä¸º0ï¼Œ ç›¸å½“äºå›ºå®š'B'
        // ç¬¬ä¸‰æ¬¡'A' ä¸ 'C'äº¤æ¢ï¼Œå­—ç¬¦ä¸²ä¸º"CBA", posä¸º0ï¼Œ ç›¸å½“äºå›ºå®š'C'
        for (int i = pos; i < s.length(); ++i) {
            swap(s[pos], s[i]);
            perm(pos+1, s, ret);
            swap(s[pos], s[i]);
            // å›æº¯çš„åŸå› ï¼šæ¯”å¦‚ç¬¬äºŒæ¬¡äº¤æ¢åæ˜¯"BAC"ï¼Œéœ€è¦å›æº¯åˆ°"ABC"
            // ç„¶åè¿›è¡Œç¬¬ä¸‰æ¬¡äº¤æ¢ï¼Œæ‰èƒ½å¾—åˆ°"CBA"
        }
    }
    vector<string> Permutation(string s) {
        if (s.empty()) return {};
        set<string> ret;
        perm(0, s, ret);
        return vector<string>({ret.begin(), ret.end()});
    }
};
```





### NC141 åˆ¤æ–­æ˜¯å¦ä¸ºå›æ–‡å­—ç¬¦ä¸²

æ°´ã€‚ç›´æ¥åˆ¤æ–­åŸå§‹ä¸²å’Œreverseåç›¸ä¸ç›¸ç­‰ã€‚

å¦‚æœä¸é¢å¤–å¼€è¾Ÿç©ºé—´çš„è¯ï¼Œå°±ç›´æ¥åŒæŒ‡é’ˆå’¯ã€‚

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     * 
     * @param str stringå­—ç¬¦ä¸² å¾…åˆ¤æ–­çš„å­—ç¬¦ä¸²
     * @return boolå¸ƒå°”å‹
     */
    bool judge(string str) {
        string ori = str;
        reverse(str.begin(), str.end());
        return ori==str;
    }
};
```



### [lc]<font color=red>1910. åˆ é™¤ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰å‡ºç°çš„ç»™å®šå­å­—ç¬¦ä¸²</font>

https://leetcode-cn.com/problems/remove-all-occurrences-of-a-substring/

2022.02.15 å­—èŠ‚é¢è¯•ç¬¬äºŒé¢˜ã€‚

ï¼ˆé¢å®Œæ‰çŸ¥é“æˆ‘å†™é”™äº†å½“æ—¶ï¼Œæˆ‘å°±è§‰å¾—å“ªæœ‰é—®é¢˜ï¼Œé¢è¯•å®˜ä¹Ÿè§‰å¾—æœ‰é—®é¢˜ï¼Œä½†æˆ‘ä¿©éƒ½æ²¡çœ‹å‡ºæ¥ã€‚ã€‚ã€‚ï¼‰

æ¨¡æ‹Ÿï¼å…¶å®è¿‡ç¨‹å¾ˆå¥½æƒ³ï¼Œä½†æ˜¯åˆ é™¤ä¹‹åæŒ‡é’ˆåº”è¯¥åœåœ¨å“ªæ˜¯ä¸ªé—®é¢˜ï¼

æ‰€ä»¥å¼•å…¥äº†ä¸€ä¸ªç±»ä¼¼äºæ ˆ/é˜Ÿåˆ—çš„æ€æƒ³ã€‚

ä¸€ä¸ªä¸€ä¸ªå‹å…¥ï¼Œ**å¦‚æœé•¿åº¦æ»¡è¶³å°±åˆ¤æ–­ä¸€ä¸‹æœ€è¿‘å‹å…¥çš„lené•¿åº¦çš„å­ä¸²æ˜¯å¦éœ€è¦åˆ ã€‚**

```
class Solution {
public:
    string removeOccurrences(string s, string part) {
        int len = part.length();

        string res;
        for(int i=0; i<s.length(); i++){
            res.push_back(s[i]);
            if(res.length()>=len){
                if(res.substr(res.size()-len, len)==part){  // åˆ æ‰resæœ«å°¾ä¸¤ä¸ª
                    res.erase(res.size()-len, len);
                }
            }
        }
        return res;
    }
};
```



### NC1 å¤§æ•°åŠ æ³•

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     * è®¡ç®—ä¸¤ä¸ªæ•°ä¹‹å’Œ
     * @param s stringå­—ç¬¦ä¸² è¡¨ç¤ºç¬¬ä¸€ä¸ªæ•´æ•°
     * @param t stringå­—ç¬¦ä¸² è¡¨ç¤ºç¬¬äºŒä¸ªæ•´æ•°
     * @return stringå­—ç¬¦ä¸²
     */
    string solve(string s, string t) {
        // å¯¹é½
        if(s.length() >= t.length()){
            t.insert(0, s.length()-t.length(), '0');
        }
        else{
            s.insert(0, t.length()-s.length(), '0');
        }
        int flag = 0;
        int temp;
        for(int i = s.length()-1; i>=0; i--){
            temp = (s[i]-'0') + (t[i]-'0') + flag;
            s[i] = temp%10 +'0';
            flag = temp/10;
        }
        if(flag) s.insert(0, "1");
        return s;
    }
};
```



### <font color=dodgerblue>NC111 æœ€å¤§æ•°</font>

cmpå‡½æ•°çš„ç¼–å†™ï¼

å°†å¤šä¸ªå­—ç¬¦ä¸²è¿›è¡Œæ’åˆ—å¹¶æ‹¼æ¥ï¼Œæ¯ä¸ªæ•°ä¸å¯æ‹†åˆ†ï¼Œä½¿å¾—æœ€åçš„ç»“æœæœ€å¤§ã€‚

è½©ç¥ç›´æ¥return s1+s2 > s2+s1ã€‚

å¯¹cmpå‡½æ•°è¿›ä¸€æ­¥ç†è§£ï¼š**bool cmp(a, b)ã€‚è‹¥è¿”å›trueï¼Œåˆ™aåœ¨bä¹‹å‰ï¼›è‹¥è¿”å›falseï¼Œåˆ™båœ¨aä¹‹å‰ã€‚**

æ‰€ä»¥å‡½æ•°å†…éƒ¨ä½ éšä¾¿å†™ï¼Œæ€ä¹ˆè¿ç®—éƒ½å¯ä»¥ï¼Œåªè¦æ»¡è¶³ä¸Šé¢çš„è§„åˆ™å°±è¡Œã€‚

è®°å¾—è€ƒè™‘ä¸º0çš„ç‰¹æ®Šæƒ…å†µã€‚

æ–¹æ³•ä¸€ï¼šï¼ˆfromè½©ç¥ï¼‰

```
class Solution {
public:
    /**
     * æœ€å¤§æ•°
     * @param nums intæ•´å‹vector 
     * @return stringå­—ç¬¦ä¸²
     */
    static bool cmp(string s1, string s2){
				return s1+s2 > s2+s1;
    }
    
    string solve(vector<int>& nums) {
        if(nums.empty()) return "0";
        vector<string>strs;
        for(int i=0; i<nums.size(); i++){
            strs.push_back(to_string(nums[i]));
        }
        sort(strs.begin(), strs.end(), cmp);
        if(strs[0][0]=='0') return "0";  // å¼€å¤´å°±æ˜¯0ï¼Œæ²¡æ•‘äº†ã€‚
        
        string ans;
        for(int i=0; i<strs.size(); i++)
            ans+=strs[i];
        return ans;
    }
};
```



æ–¹æ³•äºŒï¼šæˆ‘çš„åŸå§‹æ€è·¯

s1å’Œs2ï¼Œå¦‚æœå®Œå…¨ä¸€æ ·ï¼Œé‚£è°æ’å‰é¢éƒ½è¡Œã€‚

å¦‚æœé•¿åº¦ä¸€æ ·ä½†å€¼ä¸ä¸€æ ·ï¼Œè¿”å›å­—å…¸åºå¤§çš„é‚£ä¸ªã€‚ï¼ˆæ¯”å¦‚ "234" æ’åœ¨ "123" å‰é¢ï¼‰

å¦‚æœé•¿åº¦ä¸ä¸€æ ·ï¼Œçœ‹å…±åŒçš„å‰nä½çš„å­—å…¸åºï¼Œè¿”å›å­—å…¸åºè¾ƒå¤§çš„ã€‚ï¼ˆæ¯”å¦‚ "234" æ’åœ¨ "2333"å‰é¢ï¼‰

å¦‚æœé•¿åº¦ä¸ä¸€æ ·ï¼Œä½†å…±åŒçš„å‰nä½çš„å­—å…¸åºä¸€æ ·ï¼Œåˆ™çœ‹æ¯”è¾ƒé•¿çš„ä¸‹ä¸€ä½ã€‚ï¼ˆæ¯”å¦‚ "235" å’Œ "23"ï¼Œæ¯”è¾ƒ '5'å’Œå¼€å¤´çš„ '2'ï¼‰ã€‚

åŸå› å¾ˆæ˜¾ç„¶ï¼Œæ¯”å¦‚ s1 = "235"ï¼Œs2="23"ï¼Œs1æ’åœ¨å‰é¢æ˜¯s1+s2 = "23523"ã€‚s2+s1 = "23235"ã€‚ä»–ä»¬ä¸ä¸€æ ·çš„åœ°æ–¹å°±æ˜¯ '5'å’Œ'2'ã€‚

```
class Solution {
public:
    /**
     * æœ€å¤§æ•°
     * @param nums intæ•´å‹vector 
     * @return stringå­—ç¬¦ä¸²
     */
    static bool cmp(string s1, string s2){
        if(s1==s2) return s1>s2;
        
        int minLen = min(s1.length(), s2.length());
        if(s1.substr(0, minLen) == s2.substr(0, minLen)){
            // è§£é‡Šä¸€ä¸‹ã€‚æ¯”å¦‚ 23 å’Œ 235ï¼Œå‰ç¼€23ä¸€æ ·ã€‚ç„¶å5>2ï¼Œæ‰€ä»¥235è¦æ’åœ¨23å‰é¢
            if(minLen==s1.length()){
                return s2[minLen] < s2[0];
            }
            else{
                return s1[minLen] > s1[0];
            }
        }
        else{  // å‰nä½ä¸ä¸€æ ·ï¼Œé‚£å–å­—å…¸åºæœ€å¤§çš„ã€‚ æ¯”å¦‚"235" å’Œ "229"
            return s1 > s2;
        }
    }
    
    string solve(vector<int>& nums) {
        if(nums.empty()) return "0";
        vector<string>strs;
        for(int i=0; i<nums.size(); i++){
            strs.push_back(to_string(nums[i]));
        }
        sort(strs.begin(), strs.end(), cmp);
        if(strs[0][0]=='0') return "0";  // å¼€å¤´å°±æ˜¯0ï¼Œæ²¡æ•‘äº†ã€‚
        
        string ans;
        for(int i=0; i<strs.size(); i++)
            ans+=strs[i];
        return ans;
    }
};
```



### âš¡ï¸<font color=purple>NC28 æœ€å°è¦†ç›–å­ä¸²</font>

ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ tï¼Œè¦æ±‚åœ¨ s ä¸­æ‰¾å‡ºæœ€çŸ­çš„åŒ…å« t ä¸­æ‰€æœ‰å­—ç¬¦çš„è¿ç»­å­ä¸²ã€‚

åŒæŒ‡é’ˆã€‚é˜Ÿåˆ—æ€æƒ³ã€‚

æ—¢ç„¶ä¸è¦æ±‚é¡ºåºï¼Œé‚£ç›´æ¥ç»Ÿè®¡ä¸ªæ•°ä¸å°±è¡Œäº†ã€‚å¯¹äºsçš„æŸä¸€å­ä¸²subï¼Œåªè¦subé‡ŒåŒ…å«çš„ç›®æ ‡å­—ç¬¦ä¸ªæ•°è¶³å¤Ÿï¼Œé‚£ä¹ˆsubå°±åˆæ³•ï¼ˆæˆ‘æ²¡è¯´æœ€å°ï¼‰ã€‚

é‚£ä¹ˆå°±æ»‘åŠ¨å‘—ã€‚ é¦–å…ˆåˆå§‹åŒ–left = 0, right = 0ã€‚å¦‚æœå­ä¸²æ»¡è¶³äº†ï¼Œleftå‘å³èµ°ï¼ˆæ”¶ç¼©ï¼‰ï¼Œå¦‚æœä¸æ»¡è¶³ï¼Œrightå‘å³èµ°ï¼ˆæ‰©å±•ï¼‰ã€‚ç„¶åæ¯æ¬¡åˆæ³•éƒ½è®°å½•ä¸€ä¸‹é•¿åº¦ï¼Œæ›´æ–°å°±è¡Œäº†ã€‚

**è¾¹ç•Œé€»è¾‘è¦å¤„ç†å¥½ã€‚**

å®Œæ•´ä»£ç ï¼š

```

class Solution {
public:
    /**
     * 
     * @param S stringå­—ç¬¦ä¸² 
     * @param T stringå­—ç¬¦ä¸² 
     * @return stringå­—ç¬¦ä¸²
     */

    unordered_map<char, int> count1;
    unordered_map<char, int> count2;
    unordered_map<char, int>:: iterator it;
    int minL = INT_MAX;

    bool judge(){
        for(it=count2.begin(); it!=count2.end(); it++){
            if(!count1.count(it->first) || (count1[it->first] < it->second))
                return false;
        }
        return true;
    }

    string minWindow(string S, string T) {
        if(S.length() < T.length()) return "";
        count1.clear();
        count2.clear();

        for(int i=0; i<T.length(); i++){
            count2[T[i]]++;
        }

        int l, r;
        l = 0; r = 0;
        string res;
        while(r<S.length()){
            count1[S[r]]++;
            while(judge() && l<=r){  // å¦‚æœå½“å‰æ»¡è¶³æ¡ä»¶ï¼Œç»§ç»­æŠŠå·¦æŒ‡é’ˆå³ç§»
                if(minL > r-l+1){
                    minL = r-l+1;
                    res = S.substr(l, r-l+1);
                }
                count1[S[l]]--;
                l++;
            }
            // è¿™æ—¶å€™ä¸æ»¡è¶³äº†
            r++;
        }
        return res;
    }
};
```



### [lc]å­ä¸²çš„æœ€å¤§å‡ºç°æ¬¡æ•°

- å­ä¸²ä¸­ä¸åŒå­—æ¯çš„æ•°ç›®å¿…é¡»å°äºç­‰äº `maxLetters` ã€‚
- å­ä¸²çš„é•¿åº¦å¿…é¡»å¤§äºç­‰äº `minSize` ä¸”å°äºç­‰äº `maxSize` 

https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/

é¢˜ç›®ä¸­maxSizeæ˜¯æ²¡ç”¨çš„ã€‚å› ä¸ºé•¿çš„ä¸€å®šåŒ…å«çŸ­çš„ã€‚

æ³•ä¸€ï¼šæš´åŠ›éå†ï¼Œå…ˆæŠŠé•¿åº¦ä¸ºminSizeçš„å­ä¸²éƒ½æ”¾è¿›å»ï¼Œç„¶åæ£€æŸ¥å­ä¸²åˆæ³•æ€§å’Œæ•°é‡

```
class Solution {
public:
    map<string, int>count;
    map<char, int>kinds;

    bool isValid(string str, int maxLetters){
        kinds.clear();
        for(int i=0; i<str.length(); i++){
            kinds[str[i]]++;
        }
        if(kinds.size()>maxLetters) return false;
        return true;
    }

    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        if(maxSize<minSize) return 0;

        // å…ˆä¸¢è¿›å»ç»Ÿè®¡
        for(int i=0; i<s.length()-minSize+1; i++){
            count[s.substr(i, minSize)]++;
        }

        map<string, int>::iterator it;
        int maxx = 0;
        for(it = count.begin(); it!=count.end(); it++){
            if(isValid(it->first, maxLetters)){
                maxx = max(maxx, it->second);
            }
        }
        return maxx;
    }
};
```



æ³•äºŒï¼šæ»‘åŠ¨çª—å£ã€‚åœ¨éå†çš„åŒæ—¶è§‚å¯Ÿæ˜¯å¦åˆæ³•ï¼Œå¹¶ä¸”ç”±äºæ»‘åŠ¨çª—å£æ¯æ¬¡åªæ”¹å˜ä¸¤ä¸ªcharçš„æ•°é‡ï¼Œç»Ÿè®¡èµ·æ¥æ¯”è¾ƒå¿«ã€‚

```c++
class Solution {
public:
    
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        if(maxSize < minSize || s.size() < minSize) return 0;

        map<char, int>cnt;
        map<string, int>str_map;
        int maxx = 0;

        // åŒæŒ‡é’ˆ
        string str;
        int l =0;
        int r = minSize-1;
        str = s.substr(l, minSize);
        // ç»Ÿè®¡[l, r)
        for(int i=l; i<r; i++){
            cnt[s[i]]++;
        }
        

        // æ»‘åŠ¨çª—å£
        while(r<s.size()){
            cnt[s[r]]++;
            if(cnt.size()<=maxLetters){
                str = s.substr(l, minSize);
                str_map[str]++;
                if(maxx < str_map[str]){
                    maxx = str_map[str];
                }
            }
            cnt[s[l]]--;
            if(!cnt[s[l]]) cnt.erase(s[l]);  // è®°å¾—åˆ æ‰
            // æ»‘åŠ¨
            l++;
            r++;
        }

        return maxx;
    }
};
```





### <font color=purple>NC149 kmpç®—æ³•</font>

nextæ•°ç»„å¤šå¼€ä¸€ä½ï¼

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     *
     * è®¡ç®—æ¨¡æ¿ä¸²Såœ¨æ–‡æœ¬ä¸²Tä¸­å‡ºç°äº†å¤šå°‘æ¬¡
     * @param S stringå­—ç¬¦ä¸² æ¨¡æ¿ä¸²
     * @param T stringå­—ç¬¦ä¸² æ–‡æœ¬ä¸²
     * @return intæ•´å‹
     */
    
    void getNextTable(string pattern, int* nextTable){
        int k = -1;
        int j = 0;
        int len = pattern.length();
        nextTable[j] = k;
        while(j<len+1){
            if(k==-1 || pattern[j]==pattern[k]){
                j++;
                k++;
                nextTable[j] = k;
            }
            else{
                k = nextTable[k];
            }
        }
    }
    
    int KMP(string S, string T, int* nextTable){
        int i = 0;
        int j = 0;
        int len1 = T.length();  // ä¸»ä¸²
        int len2 = S.length();  // æ¨¡å¼ä¸²
        int count = 0;
        
        while(i<len1){
            if(j==-1 || T[i]==S[j]){
//                 printf("%d %d\n", i, j);
                i++;
                j++;
            }
            else{
                j = nextTable[j];
            }
            
            if(j==len2){  // æ‰¾åˆ°äº†ä¸€ä¸ª
                j = nextTable[j];
                count++;
            }
        }
        
        return count;
    }
    
    int kmp(string S, string T) {
        int nextTable[S.length()+1];  // å¤šå¼€ä¸€ä½ï¼
        
        getNextTable(S, nextTable);
        
        return KMP(S, T, nextTable);
    }
};
```



### NC142 æœ€é•¿é‡å¤å­ä¸²

ç¬¬ä¸€å±‚å¾ªç¯æšä¸¾é•¿åº¦ï¼Œç¬¬äºŒå±‚å¾ªç¯æšä¸¾èµ·ç‚¹ã€‚

å’Œä¸‹é¢ä¸€é¢˜æœ‰ä¸€ç‚¹ç‚¹å…³è”ã€‚

```
class Solution {
public:
    /**
     * ä»£ç ä¸­çš„ç±»åã€æ–¹æ³•åã€å‚æ•°åå·²ç»æŒ‡å®šï¼Œè¯·å‹¿ä¿®æ”¹ï¼Œç›´æ¥è¿”å›æ–¹æ³•è§„å®šçš„å€¼å³å¯
     * 
     * @param a stringå­—ç¬¦ä¸² å¾…è®¡ç®—å­—ç¬¦ä¸²
     * @return intæ•´å‹
     */
    int solve(string a) {
        int n = a.length();
        int res =  0;  // res è¡¨ç¤ºé‡å¤çš„é•¿åº¦

        int flag = 0;

        for(int i = n/2; i>0; i--){  // æšä¸¾é•¿åº¦
            for(int j=0; j< n-i; j++){  // æšä¸¾èµ·ç‚¹
                if(a[j] == a[i+j]){
                    res++;
                }
                else{
                    res = 0;
                }
                if(res == i) return i*2;  // å®Œå…¨é‡å¤
            }
        }
        return 0;
    }
};
```





### âš¡ï¸[unknown]æ±‚ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­<font color=red>è¿ç»­å‡ºç°</font>æ¬¡æ•°æœ€å¤šçš„å­ä¸²

å…ˆç¡®å®š [i, j) ä¸ [j, j+j-i] è¿™ä¸€æ®µæ˜¯å¦ç›¸ç­‰ã€‚å¦‚æœç›¸ç­‰è¯´æ˜è‡³å°‘è¿ç»­å‡ºç°äº†ã€‚

ç„¶åå¼€å§‹ä» j+j-i å¼€å§‹å¾€åæ‰¾å¾ªç¯èŠ‚ï¼Œç»Ÿè®¡æ¬¡æ•°ã€‚

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string.h>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;


string str;

int main(){
    int maxx = 0;
    string maxstr;
    string temp;
    int n = 0;
    while(getline(cin, str) && str!="#"){
        n++;
        for(int i=0; i<str.length(); i++){
            for(int j=i+1; j<str.length(); j++){
                // æ¯ä¸ªå†…å¾ªç¯ï¼Œå›ºå®šå¾ªç¯èŠ‚æ˜¯ [i, j)ï¼Œé•¿åº¦æ˜¯offset
                int count = 1;
                int offset = j-i;
                temp = str.substr(i, offset);  // å¾ªç¯èŠ‚
                if(temp == str.substr(j, offset)){
                    count++;
                }
                else continue;
                
                for(int k=j+offset; k<str.length(); k+=offset){
                    if(temp == str.substr(k, offset)){
                        count++;
                    }
                    else break;
                }
                if(maxx<count){
                    maxx = count;
                    maxstr = temp;
                }
                
                
            }
        }
        cout<<"Case: "<<n<<": "<<maxstr<<endl;
    }
    return 0;
}

```





## æ•°å­¦

### âš¡ï¸NC112 è¿›åˆ¶è½¬æ¢

è¿™ä¸ªè¿›åˆ¶è½¬æ¢æ¯”è¾ƒæ°´ï¼ŒåŸæ•°ä¸æ˜¯å¤§æ•°ï¼ˆå­—ç¬¦ä¸²ï¼‰

**ä¸æ–­è¿›è¡Œæ±‚æ¨¡å’Œæ•´é™¤è¿ç®—ï¼Œä¾¿å¯ä¾æ¬¡æ±‚å¾—è¢«ç§»åŠ¨åˆ°æœ€ä½æ•°ä½çš„å€¼ï¼›ä»¥æ­¤ç±»æ¨ï¼Œä¾¿å¯å¾—åˆ°æ‰€æœ‰æ•°ä½ä¸Šçš„å€¼ã€‚**

è®°å¾—æœ€åç¿»è½¬ä¸€ä¸‹ã€‚

å¤§æ•°çš„ä»»æ„è¿›åˆ¶è½¬æ¢å‚è€ƒ`é¢˜ç›®æ— å…³.md`

```
class Solution {
public:
    /**
     * è¿›åˆ¶è½¬æ¢
     * @param M intæ•´å‹ ç»™å®šæ•´æ•°
     * @param N intæ•´å‹ è½¬æ¢åˆ°çš„è¿›åˆ¶
     * @return stringå­—ç¬¦ä¸²
     */
    char int2char(int x){
        if(x>=0 && x<=9){
            return x+'0';
        }
        else return x-10+'A';
    }
    
    string solve(int M, int N) {
        string res;
        int flag = 0;
        if(M<0){
            M = -M;
            flag = 1;
        }
        
        while(M){
            // æ¯æ¬¡ä½œé™¤æ³•ï¼Œå¾—åˆ°ä½™æ•°
            int remain = M%N;
            M = M/N;
            res.push_back(int2char(remain));  // è®°å¾—æœ€åè¦åè¿‡æ¥
        }
        reverse(res.begin(), res.end());
        if(flag)  // æ·»åŠ è´Ÿå·
            res.insert(0, "-");
        
        return res;
    }
};
```



### âš¡ï¸<font color=fuchsia>NC79 ä¸‘æ•°</font>

**[lc]é¢è¯•é¢˜ 17.09. ç¬¬ k ä¸ªæ•°**

https://leetcode-cn.com/problems/get-kth-magic-number-lcci/

2022.02.16 å­—èŠ‚äºŒé¢ç¬¬ä¸€é¢˜



æŠŠåªåŒ…å«è´¨å› å­xxxxçš„æ•°ç§°ä½œä¸‘æ•°ï¼ˆUgly Numberï¼‰ã€‚æ±‚æŒ‰ä»å°åˆ°å¤§çš„é¡ºåºçš„ç¬¬ nä¸ªä¸‘æ•°ã€‚

å¤šæŒ‡é’ˆã€‚

æˆ‘å“­äº†å•Šï¼Œè¿™ä¸€é¢˜åœ¨æˆ‘çš„åˆ·é¢˜åˆ—è¡¨é‡Œï¼Œä½†æˆ‘æ²¡åˆ·åˆ°è¿™ä¸€é¢˜ã€‚å½“æ—¶æ²¡åšå‡ºæ¥ã€‚

è¿™ä¸€é¢˜ç”¨çš„æ˜¯2ã€3ã€5ã€‚é¢è¯•æ—¶æ˜¯2ï¼Œ3ï¼Œ5ï¼Œ7

```
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        vector<int>dp;
        dp.push_back(1);  // dp[0] = 1;
        int p1, p2, p3;
        p1 = 0; p2 = 0; p3 = 0;
        int v1, v2, v3;
        for(int i=1; i<index; i++){
            v1 = dp[p1]*2;
            v2 = dp[p2]*3;
            v3 = dp[p3]*5;
            dp.push_back(min(v1, min(v2, v3)));
            // é˜²æ­¢é‡å¤ï¼ŒåŒæ­¥ä¸€ä¸‹
            if(dp[i]==v1) p1++;
            if(dp[i]==v2) p2++;
            if(dp[i]==v3) p3++;
        }
        
        return dp[index-1];
    }
};
```



### <font color=dodgerblue>NC151 æœ€å¤§å…¬çº¦æ•°</font>

$gcd(a,b) <=> gcd(b,a\%b)$

é€’å½’å†™æ³•

```
int gcd(int a, int b){
	return b==0? a: gcd(b, a%b);
}
```

```
int gcd(int a, int b ) {
    if(b==0) return a;
    return gcd(b, a%b);
}
```

éé€’å½’å†™æ³•

```
int gcd(int a, int b) {
    if(a<b)
        swap(a, b);
    int temp;
    while(b!=0){
        temp = a;
        a = b;
        b = temp%b;
    }
    return a;
}
```





## å…¶ä»–

### å®ç°å‰ç¼€æ ‘

https://leetcode-cn.com/problems/implement-trie-prefix-tree/

å…¶å®æˆ‘æ²¡å¤ªææ‡‚å®ƒæƒ³è®©æˆ‘ç”¨ä»€ä¹ˆåšã€‚æˆ‘ç›´æ¥æš´åŠ›mapå®ç°

```
class Trie {
public:
    map<string, bool>str2bool;
    Trie() {
        str2bool.clear();
    }
    
    void insert(string word) {
        str2bool[word] = true;
    }
    
    bool search(string word) {
        if(str2bool.find(word)==str2bool.end())
            return false;
        return true;
    }
    
    bool startsWith(string prefix) {
        map<string, bool>::iterator it;
        int len = prefix.length();
        int flag = 0;  // é‡åˆ°ç¬¬ä¸€ä¸ªå­—æ¯ç›¸ç­‰çš„ï¼Œå¯åŠ¨
        for(it=str2bool.begin(); it!=str2bool.end(); it++){
            if(!flag && it->first[0]!=prefix[0])
                continue;
            flag = 1;  // è¿è¡Œåˆ°è¿™é‡Œè¯´æ˜ä¹‹å‰å·²ç»é‡åˆ°äº†ç¬¬ä¸€ä¸ªå­—ç¬¦åŒ¹é…çš„
            //mapæ˜¯æŒ‰å­—å…¸æ’åºçš„ï¼Œå¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦éƒ½ä¸åŒ¹é…ï¼Œé‚£åé¢ä¸å¯èƒ½æœ‰åŒ¹é…çš„äº†
            if(it->first[0]!=prefix[0]){
                return false;
            }
            if(it->first.substr(0,len) == prefix)
                return true;
        }
        return false;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```








## æ²¡æ¥å¾—åŠåš

